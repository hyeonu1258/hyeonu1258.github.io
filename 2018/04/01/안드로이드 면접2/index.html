<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="Hyeonu&#39;s blog">
  <meta name="keyword" content="android, java, kotlin">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      안드로이드 면접2 | 현우의 개발노트
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


</head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>현우의 개발노트</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>안드로이드 면접2</h2>
  <p class="post-date">2018-04-01</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h4 id="Java-메모리구조-Heap-Data-Stack"><a href="#Java-메모리구조-Heap-Data-Stack" class="headerlink" title="Java 메모리구조 Heap, Data, Stack"></a>Java 메모리구조 Heap, Data, Stack</h4><p><em>Java</em> 는 <em>Java</em> 코드를 컴파일러를 통해 바이트코드로 변환시킨 뒤 <em>JVM</em> 위에 실행시키는 구조이다. <em>JVM</em>은 자바 바이트코드를 실행시키는 가상머신으로서 자바가 플랫폼에 독립적으로 실행될 수 있게 한다. <em>JVM</em> 구조에는 <em>Class Loader</em>, <em>Execution Engine</em>, <em>Garbage Collector</em>, <em>Runtime Data Areas</em> 가 있다.</p>
<p><img src="http://cfile25.uf.tistory.com/image/2540294C5654207F26E12E" alt="JVM 구조"></p>
<h5 id="Class-Loader"><a href="#Class-Loader" class="headerlink" title="Class Loader"></a>Class Loader</h5><p>컴파일러에 의해 바이트코드로 변환된 코드를 <em>Runtime Data Areas</em> 에 클래스 단위로 로드시키고, <em>Link</em> 를 통해 적절히 배치시키는 작업을 한다. <em>Class Loader</em> 로 인해 동적으로 클래스를 로드할 수 있다.</p>
<h5 id="Execution-Engine"><a href="#Execution-Engine" class="headerlink" title="Execution Engine"></a>Execution Engine</h5><p><em>Runtime Data Areas</em> 에 배치된 바이트 코드를 실행시키는 역할을 한다. 메모리에 올라온 코드를 명령어 단위로 실행한다.</p>
<h5 id="Garbage-Collector"><a href="#Garbage-Collector" class="headerlink" title="Garbage Collector"></a>Garbage Collector</h5><p>어플리케이션이 생성한 객체의 생존여부를 판단하여 더 이상 사용되지 않는 객체의 메모리를 반환함으로써 메모리를 자동적으로 관리하는 역할을 한다.</p>
<h5 id="Runtime-Data-Areas"><a href="#Runtime-Data-Areas" class="headerlink" title="Runtime Data Areas"></a>Runtime Data Areas</h5><p>운영체제로부터 할당받은 메모리를 관리하는 영역이다. <em>JVM</em> 에서 관리하는 메모리 영역은 <em>Method(Static or Class) Area</em>, <em>Runtime Constant Pool</em>, <em>Heap Area</em>, <em>Stack Area</em>, <em>PC Register</em>, <em>Native Method Stack Area</em> 으로 나뉜다.</p>
<h5 id="Method-Static-or-Class-Area"><a href="#Method-Static-or-Class-Area" class="headerlink" title="Method (Static or Class) Area"></a>Method (Static or Class) Area</h5><p>호출한 클래스와 인터페이스에 대한 <em>Runtime Constant Pool</em>, 메소드와 필드, Statoc 변수, 메소드 바이트 코드 등을 저장한다.</p>
<h5 id="Runtime-Constant-Pool"><a href="#Runtime-Constant-Pool" class="headerlink" title="Runtime Constant Pool"></a>Runtime Constant Pool</h5><p><em>Method Area</em> 영역에 포함되는 공간이다. 클래스와 인터페이스 상수, 메소드와 필드에 대한 모든 <em>reference</em>를 저장한다.</p>
<p><img src="http://cfile24.uf.tistory.com/image/216AE04C5654207F0AA967" alt="Runtime Data Areas 구조"></p>
<h5 id="Heap-Area"><a href="#Heap-Area" class="headerlink" title="Heap Area"></a>Heap Area</h5><p>런타임에서 동적으로 할당하는 객체를 저장하는 공간이다. <code>new</code>연산을 통해 생성되는 객체와 배열을 저장하며 <em>GC</em>의 주 대상이 된다.</p>
<p><strong>Heap Area 메모리 관리</strong></p>
<ul>
<li><strong>Young Generation</strong> - 객체가 생성되자마자 저장되는 공간이다. 시간이 지날수록 우선순위가 낮아지며 <em>Old</em> 영역으로 내려가게 된다. 이곳에서 객체가 사라지면 <em>Minor GC</em> 가 발생한다.</li>
<li><strong>Old Generation</strong> - 오래된 객체가 저장되는 공간이다. 이곳에서 객체가 사라지면 <em>Major GC</em> 가 발생한다.</li>
<li><strong>Permanent Generation</strong> - <em>Class Loader</em> 에 의해 로드되는 클래스나 메소드에 대한 <em>Meta</em> 정보가 저장되는 영역이다. <code>Reflection</code>을 이용하여 동적으로 클래스를 로드하는 경우 자주 사용된다.</li>
</ul>
<h5 id="Stack-Area"><a href="#Stack-Area" class="headerlink" title="Stack Area"></a>Stack Area</h5><p><em>Stack</em> 구조의 저장공간이다. 함수 호출시 발생하는 지역변수, 매개변수, 연산 데이터 등을 저장하는 공간이다. 함수를 호출하면 <code>push</code>를 통해 <em>Stack</em> 에 저장하고 함수 호출이 종료되면 다음 실행할 함수를 <code>pop</code>하여 함수를 실행한다. 스레드 별로 저장공간을 따로 생성하여 관리한다.</p>
<h5 id="PC-Register"><a href="#PC-Register" class="headerlink" title="PC Register"></a>PC Register</h5><p>현재 수행 중이거나 다음에 실행할 인스트럭션 주소를 저장한다. 연산 수행 중 발생하는 데이터를 레지스터에 저장하였다가 <em>CPU</em>가 필요할 때 가져다 쓴다. 스레드 별로 공간을 만들어 관리한다</p>
<h5 id="Native-Method-Stack-Area"><a href="#Native-Method-Stack-Area" class="headerlink" title="Native Method Stack Area"></a>Native Method Stack Area</h5><p>자바가 접근할 수 없는 영역은 <code>C</code>와 같은 <em>Low Level</em> 언어로 작성되어 있다. 따라서 <em>Native</em> 코드를 실행시키면서 발생하는 데이터를 <em>Stack</em> 구조로 저장하기 위한 공간이다. 스레드 별로 생성된다.</p>
<blockquote>
<h5 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h5><p><a href="http://hipercube.tistory.com/entry/JAVA-JVM%EA%B3%BC-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0%EC%84%B1%EB%8A%A5%EA%B0%9C%EC%84%A0%EC%9D%84-%EC%9C%84%ED%95%9C-GC%EC%9D%98-%ED%99%9C%EC%9A%A9" target="_blank" rel="external">JVM과 메모리 구조(성능 개선을 이한 GC의 활용)</a></p>
</blockquote>
<h4 id="Lambda-식이란"><a href="#Lambda-식이란" class="headerlink" title="Lambda 식이란"></a>Lambda 식이란</h4><p><em>Lambda</em> 는 함수에 대한 이론적 기반을 세우는 수학적 추상화를 뜻하고 이것을 프로그래밍에 녹여서 표현한 것이 <em>Lambda</em> 표현식이다. 프로그래밍에서 <em>Lambda</em> 에 근간을 두어 설계한 패러다임이 함수형 프로그래밍이다. 함수형 프로그래밍은 함수의 입력만을 의존하여 출력을 만드는 프로그래밍 패러다임이다. 함수 개념에 근간을 두어 설계하였기에 다음과 같은 특징을 가진다.</p>
<ol>
<li>함수를 객체로 사용함으로써 값으로 할당하거나 파라미터로 전달이 가능하다. (고계함수)</li>
<li>함수를 불변상태로 규정하여 부작용을 최소화하고 멀티 스레드 환경에서 동기성 문제에 안전하다. (순수함수)</li>
<li>코드를 간결하게 하여 가독성을 높임으로써 로직에 집중시킨다. (익명함수)</li>
</ol>
<p><em>Java 8</em> 이전에는 함수에 대한 특별한 개념이 없었고 지원하는 기능도 없었다. 하지만 <em>Java 8</em> 에서부터 람다식과 함수형 인터페이스라는 개념을 도입하여 인터페이스 안에 단 하나의 함수를 선언하여 이것을 객체처럼 사용하고 람다식으로 표현이 가능하도록 지원하였다. 또한 단 하나의 함수만 들어가는 것을 보장하기 위해 <code>@FunctionalInterface</code> 라고 선언함으로써 컴파일 타임에 에러를 잡을 수 있게 하였다.</p>
<blockquote>
<h5 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h5><p><a href="https://ko.wikipedia.org/wiki/%ED%95%A8%EC%88%98%ED%98%95_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D" target="_blank" rel="external">위키백과 - 함수형 프로그래밍</a></p>
<p><a href="https://medium.com/@lazysoul/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80-d881230f2a5e" target="_blank" rel="external">Medium - 함수형 프로그래밍이란?</a></p>
<p><a href="https://skyoo2003.github.io/post/2016/11/09/java8-lambda-expression" target="_blank" rel="external">Java 8 람다 표현식 자세히 살펴보기</a></p>
</blockquote>
<h4 id="ListView의-문제점"><a href="#ListView의-문제점" class="headerlink" title="ListView의 문제점"></a>ListView의 문제점</h4><ol>
<li><em>ViewHolder Pattern</em> 을 강요하지 않는다.</li>
<li><em>Vertical</em> 모드만 지원한다.</li>
<li><em>Animation</em> 을 따로 지원하지 않기에 뷰에 대해 직접 구현해야 한다.</li>
<li>데이터가 변경될때 <code>notifyDataSetChanged()</code> 를 통해 뷰를 갱신하는데 모든 뷰를 갱신하기에 비용이 매우 크다.</li>
</ol>
<p>이러한 문제를 해결하고자 <code>RecyclerView</code> 가 나왔다. <code>RecyclerView</code> 의 장점은 <code>RecyclerView.ViewHolder</code>, <code>Layoutmanager</code>, <code>ItemAnimator</code>, <code>ItemDecoration</code>, <code>DiffUtil</code>, <code>OnItemTouchListener</code> 가 있으며 이것을 통해 문제점을 개선하였다.</p>
<h5 id="RecyclerView-ViewHolder"><a href="#RecyclerView-ViewHolder" class="headerlink" title="RecyclerView.ViewHolder"></a>RecyclerView.ViewHolder</h5><p><code>RecyclerView</code> 에서는 <code>ViewHolder</code> 를 강제하고 있기에 뷰에 대한 <code>findViewById()</code> 작업 비용을 줄일 수 있다. <code>ListView</code> 에서도 직접 패턴을 구현하여 적용할 수 있지만, 강제하지 않기 때문에 잘못 사용될 위험이 공존한다.</p>
<h5 id="LayoutManager"><a href="#LayoutManager" class="headerlink" title="LayoutManager"></a>LayoutManager</h5><p><code>LayoutManager</code>를 통해 <em>Liear</em>, <em>Grid</em>, <em>Staggered</em> 형식으로 다양하게 리스트뷰를 확장할 수 있다. <em>Liear</em>에서는 <em>Horizontal</em>, <em>Vertical</em> 모드를 지원하기에 오픈 소스를 찾거나 커스텀 할 필요없이 쉽게 구현이 가능하다.</p>
<h5 id="ItemAnimator"><a href="#ItemAnimator" class="headerlink" title="ItemAnimator"></a>ItemAnimator</h5><p><code>animateAdd</code>, <code>animateRemove</code>, animateMove` 를 구현함으로써 추가, 삭제, 변경시 적용할 애니메이션을 쉽게 적용할 수 있다.</p>
<h5 id="ItemDecoration"><a href="#ItemDecoration" class="headerlink" title="ItemDecoration"></a>ItemDecoration</h5><p><code>ListView</code> 에서는 <em>xml</em> 파일에 <code>android:divider</code> 항목을 추가함으로써 구현할 수 있지만 모양과 크기를 유연하게 커스텀하기 어렵다. <code>ItemDecoration</code> 은 뷰가 그려질 때 공백을 넣거나, 경계선을 추가하는 등 뷰를 꾸미는 작업을 쉽고 다양하게 적용할 수 있다. 따라서 별도의 뷰를 추가하여 성능 저하가 발생하거나, <code>padding</code> 을 통해 뷰에 공백을 추가하여 애니메이션이 어색해지는 문제를 해결할 수 있다.</p>
<h5 id="DiffUtil"><a href="#DiffUtil" class="headerlink" title="DiffUtil"></a>DiffUtil</h5><p><code>DiffUtil</code>은 데이터의 변화를 감지하여 뷰를 갱신하는 클래스이다. <code>areItemsTheSame</code>, <code>areContentsTheSame</code>, <code>getChangePayload</code> 등을 오버라이딩하여 데이터간 변화를 감지한다. <code>RecyclerView.Adatper</code> 에서 <code>notifyItemMoved</code>, <code>notifyItemRangeChanged</code>, <code>notifyItemRangeInserted</code>, <code>notifyItemRangeRemoved</code> 가 호출되면 <code>DiffUtil</code> 에서 해당 범위의 데이터의 변화를 감지하고 뷰를 선택적으로 갱신함으로써 비용이 큰 <code>notifyDataSetChanged</code> 대신 효율적으로 사용될 수 있다.</p>
<h5 id="OnItemTouchListener"><a href="#OnItemTouchListener" class="headerlink" title="OnItemTouchListener"></a>OnItemTouchListener</h5><p><code>ListView</code> 는 <code>OnItemClickListener</code> 를 통해 아이템 클릭 이벤트를 쉽게 구현할 수 있었다. 반면 <code>RecyclerView</code> 는 <code>OnItemTouchListener</code> 에서 <em>GestureDetector</em> 를 이용하여 클릭뿐만 아니라 롱클릭이나 탭 등의 다양한 제스쳐 이벤트를 구현할 수 있다. 하지만 구현이 복잡하다는 단점이 있다.</p>
<blockquote>
<h5 id="참고-1"><a href="#참고-1" class="headerlink" title="참고"></a>참고</h5><p><a href="https://spotandroid.com/2017/02/05/recyclerview-listview-basic-comparison/" target="_blank" rel="external">RecyclerView &amp; ListView basic comparison</a></p>
<p><a href="https://stackoverflow.com/questions/26570325/what-are-recyclerview-advantages-compared-to-listview" target="_blank" rel="external">StackOverFlow - What are RecyclerView advantages compared to ListView</a></p>
<p><a href="https://proandroiddev.com/itemdecoration-in-android-e18a0692d848" target="_blank" rel="external">ProAndroidDev - ItemDecoration in Android</a></p>
<p><a href="https://android.jlelse.eu/smart-way-to-update-recyclerview-using-diffutil-345941a160e0" target="_blank" rel="external">AndroidPub - Smart way to update RecyclerView using DiffUtil</a></p>
<p><a href="http://liveonthekeyboard.tistory.com/136" target="_blank" rel="external">Recyclerview OnItemClick 리스너 구현</a></p>
</blockquote>
<h4 id="자바-동등성과-동일성"><a href="#자바-동등성과-동일성" class="headerlink" title="자바 동등성과 동일성"></a>자바 동등성과 동일성</h4><p>두 객체를 비교할때 완전히 같은 객체일 경우 <strong>동등성 (equivalent)</strong>이라하고 객체에 대한 정보가 같을 경우 <strong>동일성 (identity)</strong>이라고 한다. <strong>동등성 검사</strong>는 <code>equals()</code> 를 사용하고 <strong>동일성 검사</strong>는 <code>hashCode()</code> 를 사용한다. <code>equals()</code> 를 오버라이딩 하지 않을 경우 <code>Object</code> 클래스의 <code>equals()</code> 에 의해 해시값을 비교하기 때문에 동일성 검사가 이루어진다. 따라서 제대로된 동등성 검사를 하기 위해서는 <code>equals()</code> 를 오버라이딩 해야한다. <code>hashCode()</code> 는 객체별 고유의 해시키를 부여함으로써 객체를 구분한다. 동일한 객체가 아니더라도 같은 객체로 인식하고 싶다면 <code>hashCode()</code> 또한 오버라이딩을 해야한다. <code>HashMap</code>, <code>HashSet</code>, <code>HashTable</code> 에서는 객체를 구분할때 <code>equals()</code> 가 아니라 <code>hashCode()</code> 를 사용하여 구분하기에 이러한 자료구조를 사용하기 위해서는 <code>hashCode()</code> 를 오버라이딩하여야 제대로 사용이 가능하다. <code>Map</code> 은 데이터를 추가하는 순간부터 객체의 해시값을 기억하므로 이후에 객체의 데이터가 변경되더라도(해시값이 변경되어도) <code>Map</code> 은 인지를 하지 못한다. 따라서 <code>Map</code> 의 키에 추가되는 데이터는 <em>immutable</em> 해야한다.</p>
<blockquote>
<h5 id="참고-2"><a href="#참고-2" class="headerlink" title="참고"></a>참고</h5><p><a href="http://anster.tistory.com/160" target="_blank" rel="external">Java 의 equals 와 hashCode, 동등성과 동일성</a></p>
<p><a href="https://stackoverflow.com/questions/4360035/why-can-hashcode-return-the-same-value-for-different-objects-in-java" target="_blank" rel="external">StackOverFlow - Why can hashCode() return the same value for different objects in Java?</a></p>
</blockquote>
<h4 id="자바에서-다중상속을-막은-이유"><a href="#자바에서-다중상속을-막은-이유" class="headerlink" title="자바에서 다중상속을 막은 이유"></a>자바에서 다중상속을 막은 이유</h4><p>다중 상속에는 여러가지 문제가 내재되어 있다. 예를 들어 변수명 충돌이나 중복된 클래스 상속으로 인해 오버라이딩이 모호한 다이아몬드 문제가 대표적이다. 무엇보다 자바는 객체지향언어이기에 다중상속을 지원하면 객체지향이 무너질 수 있다. 객체지향의 단일책임 원칙에 의해 클래스는 오직 하나의 기능을 가지고 그 하나의 책임에 집중해야되며, 리스코브 치환 원칙에 따라 자식 클래스를 몰라도 부모 클래스의 함수를 사용할 수 있도록 대치가 가능해야 한다. 하지만 다중상속을 허용하면 클래스의 성질이 복합적으로 섞여 부모와 <em>IS-A</em> 관계가 모호해져 정체성이 불분명해질 수 있다. 이것은 위 객체지향 원칙에 위배되기에 이런 문제를 막고자 다중상속을 금지하였다. 하지만 단일 상속은 클래스를 경직되게 만들고 유연한 구현이 불가하다. 자바는 이런문제를 <code>Interface</code> 와 <em>Composition Pattern</em> 을 사용하여 해결할 수 있다. 구현에 대한 책임을 <code>implements</code> 하는 클래스에 위임함으로써 다이아몬드 문제를 해결할 수 있고 상속이 아닌 <em>mixin</em> 개념을 사용하여 기능을 확장시킬 수 있다. <em>mixin</em> 은 클래스가 주 자료형 이외에 추가로 구현할 수 있는 자료형으로써 새로운 기능을 제공할 수 있다. 결국 자료형을 확장함으로써 기능을 추가하되 객체의 정체성은 유지할 수 있다. <em>Composition Pattern</em> 은 구성이라는 개념을 사용한다. 여러 클래스를 멤버필드에 포함시켜 객체의 기능은 확장시키고 부모 클래스로부터 받은 성격은 유지할 수 있다.</p>
<blockquote>
<h5 id="참고-3"><a href="#참고-3" class="headerlink" title="참고"></a>참고</h5><p><a href="http://gyumee.egloos.com/m/3200829" target="_blank" rel="external">자바가 다중 상속을 지원하지 않는 이유?</a></p>
<h5 id="객체지향-개발-5대원리-SOLID"><a href="#객체지향-개발-5대원리-SOLID" class="headerlink" title="객체지향 개발 5대원리:SOLID"></a><a href="http://www.nextree.co.kr/p6960/" target="_blank" rel="external">객체지향 개발 5대원리:SOLID</a></h5></blockquote>
<h4 id="해시코드란"><a href="#해시코드란" class="headerlink" title="해시코드란"></a>해시코드란</h4><p>객체를 구분하기 위해 고유한 숫자를 제공하는 함수이다. 내부적으로는 해시함수를 통해 임의의 길이의데이터를 고정된 길이의 데이터로 매핑하여 고유한 숫자를 만들어낸다. 객체의 주소는 해시값으로 인덱싱이 되어 있어 메모리 주소를 16진수의 해시값으로 반환된다.</p>
<blockquote>
<h5 id="참조-1"><a href="#참조-1" class="headerlink" title="참조"></a>참조</h5><p><a href="http://hsp1116.tistory.com/35" target="_blank" rel="external">해쉬 알고리즘 요약 정리</a></p>
</blockquote>
<h4 id="Object-클래스에-무슨-함수가-있는가"><a href="#Object-클래스에-무슨-함수가-있는가" class="headerlink" title="Object 클래스에 무슨 함수가 있는가"></a>Object 클래스에 무슨 함수가 있는가</h4><p>객체를 위한 메소드와 스레드를 위한 메소드로 나뉜다. 스레드를 위한 함수는 <code>final</code> 로 선언되어 있어 오버라이딩이 불가하다.</p>
<h5 id="equals-Object-obj"><a href="#equals-Object-obj" class="headerlink" title="equals(Object obj)"></a>equals(Object obj)</h5><p>두 개의 객체를 비교</p>
<h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h5><p>객체에 대한 정보를 문자열로 반환한다. 오버라이딩하지 않을 경우 객체의 해시코드를 출력한다.</p>
<h5 id="protected-clone"><a href="#protected-clone" class="headerlink" title="protected clone()"></a>protected clone()</h5><p>객체를 복제하여 새로운 객체를 반환한다. 단지 필드 값만 복사하기에 필드의 값이 배열이나 객체이면 제대로된 깊은 복사가 이루어지지 않는다. 제대로 사용하려면 <code>Cloneable</code> 을 구현하여야 한다.</p>
<h5 id="protected-finalize"><a href="#protected-finalize" class="headerlink" title="protected finalize()"></a>protected finalize()</h5><p><em>GC</em> 에 객체를 반환한다.</p>
<h5 id="getClass"><a href="#getClass" class="headerlink" title="getClass()"></a>getClass()</h5><p>클래스 자료형을 반환한다.</p>
<h5 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h5><p>객체의 고유 해시값을 반환한다. 해시값은 객체의 주소 인덱싱에 사용되기에 주소값을 16진수로 변환해서 반환한다.</p>
<h5 id="notify"><a href="#notify" class="headerlink" title="notify()"></a>notify()</h5><p>wait된 스레드 실행을 재개한다.</p>
<h5 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll()"></a>notifyAll()</h5><p>wait된 모든 스레드를 실행한다.</p>
<h5 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h5><p>다른 스레드가 <code>notify</code> 를 호출때까지 스레드를 일시적으로 중지한다.</p>
<h5 id="wait-long-timeout"><a href="#wait-long-timeout" class="headerlink" title="wait(long timeout)"></a>wait(long timeout)</h5><p>다른 스레드가 <code>notify</code> 를 호출하거나 일정시간이 지날때까지 스레드를 중지한다.</p>
<h5 id="wait-long-timeout-int-nanos"><a href="#wait-long-timeout-int-nanos" class="headerlink" title="wait(long timeout, int nanos)"></a>wait(long timeout, int nanos)</h5><p>다른 스레드가 <code>notify</code> 를 호출하거나 일정시간이 지나거나 인터럽트를 당할때까지 일정시간만큼 스레드를 중지한다.</p>
<blockquote>
<h5 id="참조-2"><a href="#참조-2" class="headerlink" title="참조"></a>참조</h5><p><a href="http://tcpschool.com/java/java_api_object" target="_blank" rel="external">Object 클래스</a></p>
</blockquote>
<h4 id="Class를-immutable-하게-하려면-어떻게-해야되는가"><a href="#Class를-immutable-하게-하려면-어떻게-해야되는가" class="headerlink" title="Class를 immutable 하게 하려면 어떻게 해야되는가"></a>Class를 immutable 하게 하려면 어떻게 해야되는가</h4><p>클래스 선언시 <code>final</code> 키워드를 사용하여 변경을 막습니다. 멤버변수 선언 또한 <code>final</code> 을 사용함으로써 멤버변수의 변경을 막아야한다. 대표적인 <em>Immutable Class</em> 는 <code>String</code>, <code>Integer</code>, <code>Boolean</code>, <code>Float</code>, <code>Long</code>, <code>Double</code> 등이 있다. 클래스를 불변하게 만들면 멀티 스레드 환경에서 안정적인 사용이 보장된다. <em>Immutable Class</em> 는 멤버변수를 초기화를 주의해야한다. 생성자를 통해 멤버변수를 초기화를 할때 그대로 가져다 쓸 경우 생성자의 파라미터로 넘겼던 객체를 변경하면 <em>Immutable Class</em> 의 멤버변수도 변경하는 문제가 생긴다. 따라서 멤버변수는 반드시 복사를 하여 초기화를 해야된다.</p>
<blockquote>
<h5 id="참고-4"><a href="#참고-4" class="headerlink" title="참고"></a>참고</h5><p><a href="http://hashcode.co.kr/questions/727/%EC%9E%90%EB%B0%94%EC%97%90%EC%84%9C-immutable%EC%9D%B4-%EB%AD%94%EA%B0%80%EC%9A%94" target="_blank" rel="external">hashcode - 자바에서 Immutable이 뭔가요?</a></p>
</blockquote>
<h4 id="디자인-패턴에-대해-설명과-구현"><a href="#디자인-패턴에-대해-설명과-구현" class="headerlink" title="디자인 패턴에 대해 설명과 구현"></a>디자인 패턴에 대해 설명과 구현</h4><h5 id="싱글톤"><a href="#싱글톤" class="headerlink" title="싱글톤"></a>싱글톤</h5><p>객체를 단 하나만 생성하도록 제한하고자할때 사용한다. 멀티 스레드에서 동기화 문제가 유발되는 클래스이거나 객체 생성시 리소스가 매우 큰 경우 하나만 생성하고 이것을 재사용함으로써 자원의 효율과 동기화 문제를 막을 수 있다. 하지만 멀티 스레드 환경에서 하나의 객체만 생성하도록 컨트롤하는 것이 매우 어렵고 복잡하다는 단점이 있다. 안드로이드에서는 <em>Network Connection</em> 클래스를 싱글톤으로 생성하여 사용한다.</p>
<h5 id="팩토리"><a href="#팩토리" class="headerlink" title="팩토리"></a>팩토리</h5><p>객체를 만드는 일을 서브 클래스에 위임할때 사용한다. 구조적으로 보면 팩토리 인터페이스를 정의하고 인터페이스를 구현하는 클래스에서 여러 클래스에 대해 객체를 생성하는 구조를 가진다. 팩토리 패턴을 사용하면 객체를 직접 생성하는 것이 아니라 서브 클래스가 생성하도록 설계함으로써 클래스간 결합도를 낮출 수 있다. 안드로이드에서는 프래그먼트를 생성 및 관리할때 팩토리 메소드 패턴을 사용할 수 있다.</p>
<blockquote>
<h5 id="참고-5"><a href="#참고-5" class="headerlink" title="참고"></a>참고</h5><p><a href="http://jusungpark.tistory.com/14" target="_blank" rel="external">디자인패턴 - 팩토리 패턴(factory pattern)</a></p>
</blockquote>
<h5 id="빌더"><a href="#빌더" class="headerlink" title="빌더"></a>빌더</h5><p>생성자에서 파라미터의 수가 많아지면 코드 작성이 어렵고 읽기가 어려워진다. 이러한 문제를 해결하기 위해 자바빈 패턴이 사용되었다. 파라미터를 <code>set()</code> 함수를 통해 각각 초기화함으로써 읽기도 쉽고 코드 작성도 수월하지만 1회의 함수 호출로 생성를 끝낼 수 없는 단점이 생겼다. 이 단점은 객체의 일관성을 일시적으로 깰 수 있는 치명성이 있는데, 만약 일관성이 깨진 객체가 잘 못 사용된다면 어디서 문제가 발생하였는지 디버깅하기가 매우 어려워진다. 따라서 이러한 문제를 해결하려면 변경 불가능 클래스 성격이 더해져야한다. 이를 위해 <em>freezing</em> 개념이 들어간 패턴이 빌더 패턴이다. <code>build()</code> 함수를 호출하기 전까지 파라미터를 선택적으로 초기화할 수 있되 <code>Builder</code> 클래스를 반환함으로써 객체를 얼릴 수 있다. <code>build()</code> 함수를 호출하면 내부적으로 파라미터 검사를 추가적으로하여 오류를 잡을 수 있다. 파라미터를 초기화하는 함수명도 변수명과 일치시켜 가독성을 매우 높일 수 있다는 장점도 있다. 안드로이드에서는 <em>Request Query</em> 를 빌더패턴으로 구현하여 사용한다.</p>
<h5 id="어댑터"><a href="#어댑터" class="headerlink" title="어댑터"></a>어댑터</h5><p>클래스의 인터페이스를 사용자가 기대하는 다른 인터페이스로 변환하는 패턴이다. 인터페이스 호환성 문제로 같이 사용할 수 없는 클래스를 연결할때 사용한다.</p>
<p><img src="http://cfile9.uf.tistory.com/image/256C6A47575EB04330794D" alt="어댑터 패턴"></p>
<blockquote>
<h5 id="참고-6"><a href="#참고-6" class="headerlink" title="참고"></a>참고</h5><p><a href="http://jusungpark.tistory.com/22" target="_blank" rel="external">디자인 패턴 - 어댑터 패턴(adapter pattern)</a></p>
</blockquote>
<h5 id="컴포지트"><a href="#컴포지트" class="headerlink" title="컴포지트"></a>컴포지트</h5><p>객체들을 트리 구조로 구성하여 개별 객체와 복합 객체를 같은 방식으로 처리하는 패턴이다. <em>Component</em> 인터페이스를 통해 표현할 요소를 정의하고 <em>Leaf</em> 와 <em>Composite</em> 클래스가 이것을 구현함으로써 개별 및 복합 객체를 동일한 <em>Component</em> 로 처리할 수 있다. 안드로이드에서는 <code>View</code> 와 <code>ViewGroup</code> 이 컴포지트 패턴으로 사용된 예이다.</p>
<p><img src="http://cfile7.uf.tistory.com/image/262FAC4F57839ACC1886C8" alt="컴포지트 패턴"></p>
<blockquote>
<h5 id="참고-7"><a href="#참고-7" class="headerlink" title="참고"></a>참고</h5><p><a href="http://jdm.kr/blog/228" target="_blank" rel="external">컴포지트 패턴(Composite Pattern)</a></p>
<p><a href="http://jusungpark.tistory.com/26" target="_blank" rel="external">컴포지트 패턴(composite pattern)</a></p>
</blockquote>
<h5 id="반복자"><a href="#반복자" class="headerlink" title="반복자"></a>반복자</h5><p>사용자가 내부 구조를 알 필요없이 내부 데이터에 동일한 방식으로 접근할 수 있도록 설계하는 패턴이다. 내부 구현 코드를 숨길 수 있기에 정보은닉이 가능하고 사용자는 편리한 인터페이스를 경험할 수 있다. 자바의 컬렉션에서 데이터 탐색이 <code>Iterator</code> 로 구현되어 있다. <code>List</code>, <code>Set</code>, <code>Map</code> 의 내부구조를 알 필요없이 같은 방식으로 순차접근이 가능하여 쉽게 사용할 수 있다.</p>
<h5 id="옵저버"><a href="#옵저버" class="headerlink" title="옵저버"></a>옵저버</h5><p>한 객체의 상태를 체크하다가 변화가 생기면 여기에 의존하는다른 객체에 이벤트를 보내어 변화에 대해 갱신을 하는 패턴이다. 일대다 의존성을 보이는 특징이 있다. 상태를 저장하는 주제객체(<em>Subject</em> 또는 <em>Publisher</em>)와 주제객체에 의존하여 변화를 감지하는 여러개의 옵저버 객체가 있는 구조이며 옵저버 객체는 옵저버 인터페이스를 통해 구현한다. 주제객체와 옵저버 객체간의 결합은 느슨한 결합을 유지함으로써 주제는 옵저버가 어떤 클래스인지 알 필요가 없다. 다만 옵저버 인터페이스인지만 확인할 뿐이다.  따라서 옵저버의 추가와 제거가 자유롭고 서로의 변경에도 영향을 끼치지 않는 독립성을 가질 수 있는 장점이 있다. 주제객체는 옵저버 객체에게 <em>PUSH</em> 를 통해 변화를 알리면 옵저버 객체가 변화에 대응하는 방법이 있고, 주제객체를 감지하는 감시자(<em>Watcher</em>)가 <em>PULL</em> 을 통해 주제객체의 상태정보를 가져와서 옵저버 객체들을 갱신시키는 방법이 있다.</p>
<p><img src="https://i0.wp.com/friday.fun25.co.kr/blog/wp-content/uploads/2017/03/observer.png?w=704" alt="옵저버 패턴"></p>
<blockquote>
<h5 id="참조-3"><a href="#참조-3" class="headerlink" title="참조"></a>참조</h5><p><a href="http://friday.fun25.co.kr/blog/?p=157" target="_blank" rel="external">디자인패턴:옵저버패턴(OBSERVER PATTERN)</a></p>
</blockquote>
<h5 id="스트래티지"><a href="#스트래티지" class="headerlink" title="스트래티지"></a>스트래티지</h5><p>알고리즘군(또는 기능)을 정의하고 각각을 캡슐화하여 교환할 수 있도록 만드는 패턴이다. 알고리즘(기능)을 사용하는 클라이언트와 독립적으로 알고리즘을 변경할 수 있는 장점이 있다. <strong>인터페이스</strong>와 <strong>구성</strong>을 사용한다. 인터페이스를 통해 새로운 알고리즘(기능)을 정의하고 이것을 구현한 클래스(기능 클래스)를 멤버필드로 포함(<strong>구성</strong>)시키는 구조이다. 구현이 아닌 구성을 활용하였기에 코드 재사용성이 높다. 또한 캡슐화에 의해 알고리즘 내부 구조와 상관없이 클래스가 제공하는 메소드(클래스가 달라도 동일한 메소드)를 사용한다. 따라서 인터페이스가 편리하다.</p>
<p><img src="http://cfile26.uf.tistory.com/image/24165B475725F4050CBF9D" alt="스트래티지 패턴"></p>
<blockquote>
<h5 id="참고-8"><a href="#참고-8" class="headerlink" title="참고"></a>참고</h5><p><a href="http://jusungpark.tistory.com/7" target="_blank" rel="external">디자인패턴 - 스트래티지 패턴(strategy pattern)</a></p>
</blockquote>
<h4 id="곱셉을-할때-속도를-빠르게-하려면-어떻게-할-것인가"><a href="#곱셉을-할때-속도를-빠르게-하려면-어떻게-할-것인가" class="headerlink" title="곱셉을 할때 속도를 빠르게 하려면 어떻게 할 것인가"></a>곱셉을 할때 속도를 빠르게 하려면 어떻게 할 것인가</h4><p>처음부터 곱셈결과를 배열에 저장해놓고 그것을 가져다 쓰도록 하여 속도를 향상시킨다.</p>
<h4 id="오버라이딩과-오버로딩의-차이-시그니처"><a href="#오버라이딩과-오버로딩의-차이-시그니처" class="headerlink" title="오버라이딩과 오버로딩의 차이 (시그니처)"></a>오버라이딩과 오버로딩의 차이 (시그니처)</h4><p>오버라이딩과 오버로딩은 자바의 다형성을 구현하는 대표적인 방법이다. 오버라이딩은 하위 클래스의 성격에 맞게 부모 클래스의 함수를 재정의하는 것을 말한다. 이때 부모 클래스와의 시그니쳐가 완전히 같지만 내부 구현이 달라지는 형태이다. 오버로딩은 함수 이름만 같고 나머지 시그니쳐가 다른 것을 말한다. 파라미터 자료형이나, 개수 등을 다르게 정의함으로써 확장된 함수를 새로 정의하고 구현하는 것을 말한다.</p>
<h4 id="OOP-란-의존성-역전"><a href="#OOP-란-의존성-역전" class="headerlink" title="OOP 란 (의존성 역전)"></a>OOP 란 (의존성 역전)</h4><blockquote>
<h5 id="참조-4"><a href="#참조-4" class="headerlink" title="참조"></a>참조</h5><p><a href="http://www.nextree.co.kr/p6960/" target="_blank" rel="external">객체지향 개발 5대 원리:SOLID</a></p>
</blockquote>
<h4 id="리플렉션이란"><a href="#리플렉션이란" class="headerlink" title="리플렉션이란"></a>리플렉션이란</h4><h4 id="Serialization-이란"><a href="#Serialization-이란" class="headerlink" title="Serialization 이란"></a>Serialization 이란</h4><h4 id="Set-vs-List"><a href="#Set-vs-List" class="headerlink" title="Set vs List"></a>Set vs List</h4><h4 id="Looper-와-Handler"><a href="#Looper-와-Handler" class="headerlink" title="Looper 와 Handler"></a>Looper 와 Handler</h4><h4 id="메인-스레드가-아닌-스레도에도-루퍼가-있는가-어떻게-만들-수-있나"><a href="#메인-스레드가-아닌-스레도에도-루퍼가-있는가-어떻게-만들-수-있나" class="headerlink" title="메인 스레드가 아닌 스레도에도 루퍼가 있는가? 어떻게 만들 수 있나?"></a>메인 스레드가 아닌 스레도에도 루퍼가 있는가? 어떻게 만들 수 있나?</h4><h4 id="Looper-quit-와-quitsafely-차이"><a href="#Looper-quit-와-quitsafely-차이" class="headerlink" title="Looper.quit() 와 quitsafely 차이"></a>Looper.quit() 와 quitsafely 차이</h4><h4 id="새로운-안드로이드-버전-특징-8"><a href="#새로운-안드로이드-버전-특징-8" class="headerlink" title="새로운 안드로이드 버전 특징 (8 ~)"></a>새로운 안드로이드 버전 특징 (8 ~)</h4><h4 id="안드로이드-4대-컴포넌트"><a href="#안드로이드-4대-컴포넌트" class="headerlink" title="안드로이드 4대 컴포넌트"></a>안드로이드 4대 컴포넌트</h4><h4 id="Intent-Flag-설명-SingleTop-ClearTop"><a href="#Intent-Flag-설명-SingleTop-ClearTop" class="headerlink" title="Intent Flag 설명 (SingleTop, ClearTop)"></a>Intent Flag 설명 (SingleTop, ClearTop)</h4><h4 id="Context-란"><a href="#Context-란" class="headerlink" title="Context 란"></a>Context 란</h4><h4 id="Java-8에-추가된-것들"><a href="#Java-8에-추가된-것들" class="headerlink" title="Java 8에 추가된 것들"></a>Java 8에 추가된 것들</h4><h4 id="메인스레드에-대해-설명"><a href="#메인스레드에-대해-설명" class="headerlink" title="메인스레드에 대해 설명"></a>메인스레드에 대해 설명</h4><h4 id="MVC-MVP-MVVM"><a href="#MVC-MVP-MVVM" class="headerlink" title="MVC, MVP, MVVM"></a>MVC, MVP, MVVM</h4><h4 id="SparseArray-와-HashMap-차이"><a href="#SparseArray-와-HashMap-차이" class="headerlink" title="SparseArray 와 HashMap 차이"></a>SparseArray 와 HashMap 차이</h4><h4 id="TedPermission-작동-원리"><a href="#TedPermission-작동-원리" class="headerlink" title="TedPermission 작동 원리"></a>TedPermission 작동 원리</h4><h4 id="이벤트-버스란-대체할-것은"><a href="#이벤트-버스란-대체할-것은" class="headerlink" title="이벤트 버스란? 대체할 것은?"></a>이벤트 버스란? 대체할 것은?</h4><h4 id="LRU-cache"><a href="#LRU-cache" class="headerlink" title="LRU cache"></a>LRU cache</h4><h4 id="버터나이프-뷰인젝터-만들어지는-과정"><a href="#버터나이프-뷰인젝터-만들어지는-과정" class="headerlink" title="버터나이프, 뷰인젝터 만들어지는 과정"></a>버터나이프, 뷰인젝터 만들어지는 과정</h4><h4 id="액티비티와-프래그먼트-차이"><a href="#액티비티와-프래그먼트-차이" class="headerlink" title="액티비티와 프래그먼트 차이"></a>액티비티와 프래그먼트 차이</h4></section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#취업준비" >
    <span class="tag-code">취업준비</span>
  </a>

      </div>
    
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2018/03/26/안드로이드 면접/">
        <span class="nav-arrow">← </span>
        
          안드로이드 면접
        
      </a>
    
    
  </div>

    
      <div class="money-like">
        <div class="reward-btn">
          후원
        <span class="money-code">
          <span class="kakaopay-code">
            <div class="code-image"></div>
          </span>
        </span>
        </div>
      <p class="notice">이 포스트가 도움이 되었다고 생각하시면, 위의 버튼을 클릭하여 후원해주세요.</p>
      </div>
    
    
      <div class="qrcode">
        <canvas id="share-qrcode"></canvas>
      <p class="notice">이 포스트를 공유하려면 QR 코드를 스캔하세요.</p>
      </div>
    
    
      <div id="comments"></div>
      <!-- Gitment END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Java-메모리구조-Heap-Data-Stack"><span class="toc-nav-text">Java 메모리구조 Heap, Data, Stack</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#Class-Loader"><span class="toc-nav-text">Class Loader</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#Execution-Engine"><span class="toc-nav-text">Execution Engine</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#Garbage-Collector"><span class="toc-nav-text">Garbage Collector</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#Runtime-Data-Areas"><span class="toc-nav-text">Runtime Data Areas</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#Method-Static-or-Class-Area"><span class="toc-nav-text">Method (Static or Class) Area</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#Runtime-Constant-Pool"><span class="toc-nav-text">Runtime Constant Pool</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#Heap-Area"><span class="toc-nav-text">Heap Area</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#Stack-Area"><span class="toc-nav-text">Stack Area</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#PC-Register"><span class="toc-nav-text">PC Register</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#Native-Method-Stack-Area"><span class="toc-nav-text">Native Method Stack Area</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#참고"><span class="toc-nav-text">참고</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Lambda-식이란"><span class="toc-nav-text">Lambda 식이란</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#참조"><span class="toc-nav-text">참조</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#ListView의-문제점"><span class="toc-nav-text">ListView의 문제점</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#RecyclerView-ViewHolder"><span class="toc-nav-text">RecyclerView.ViewHolder</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#LayoutManager"><span class="toc-nav-text">LayoutManager</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#ItemAnimator"><span class="toc-nav-text">ItemAnimator</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#ItemDecoration"><span class="toc-nav-text">ItemDecoration</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#DiffUtil"><span class="toc-nav-text">DiffUtil</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#OnItemTouchListener"><span class="toc-nav-text">OnItemTouchListener</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#참고-1"><span class="toc-nav-text">참고</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#자바-동등성과-동일성"><span class="toc-nav-text">자바 동등성과 동일성</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#참고-2"><span class="toc-nav-text">참고</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#자바에서-다중상속을-막은-이유"><span class="toc-nav-text">자바에서 다중상속을 막은 이유</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#참고-3"><span class="toc-nav-text">참고</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#객체지향-개발-5대원리-SOLID"><span class="toc-nav-text">객체지향 개발 5대원리:SOLID</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#해시코드란"><span class="toc-nav-text">해시코드란</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#참조-1"><span class="toc-nav-text">참조</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Object-클래스에-무슨-함수가-있는가"><span class="toc-nav-text">Object 클래스에 무슨 함수가 있는가</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#equals-Object-obj"><span class="toc-nav-text">equals(Object obj)</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#toString-NaN"><span class="toc-nav-text">toString()</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#protected-clone"><span class="toc-nav-text">protected clone()</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#protected-finalize"><span class="toc-nav-text">protected finalize()</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#getClass"><span class="toc-nav-text">getClass()</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#hashCode"><span class="toc-nav-text">hashCode()</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#notify"><span class="toc-nav-text">notify()</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#notifyAll"><span class="toc-nav-text">notifyAll()</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#wait"><span class="toc-nav-text">wait()</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#wait-long-timeout"><span class="toc-nav-text">wait(long timeout)</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#wait-long-timeout-int-nanos"><span class="toc-nav-text">wait(long timeout, int nanos)</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#참조-2"><span class="toc-nav-text">참조</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Class를-immutable-하게-하려면-어떻게-해야되는가"><span class="toc-nav-text">Class를 immutable 하게 하려면 어떻게 해야되는가</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#참고-4"><span class="toc-nav-text">참고</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#디자인-패턴에-대해-설명과-구현"><span class="toc-nav-text">디자인 패턴에 대해 설명과 구현</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#싱글톤"><span class="toc-nav-text">싱글톤</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#팩토리"><span class="toc-nav-text">팩토리</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#참고-5"><span class="toc-nav-text">참고</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#빌더"><span class="toc-nav-text">빌더</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#어댑터"><span class="toc-nav-text">어댑터</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#참고-6"><span class="toc-nav-text">참고</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#컴포지트"><span class="toc-nav-text">컴포지트</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#참고-7"><span class="toc-nav-text">참고</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#반복자"><span class="toc-nav-text">반복자</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#옵저버"><span class="toc-nav-text">옵저버</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#참조-3"><span class="toc-nav-text">참조</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#스트래티지"><span class="toc-nav-text">스트래티지</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#참고-8"><span class="toc-nav-text">참고</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#곱셉을-할때-속도를-빠르게-하려면-어떻게-할-것인가"><span class="toc-nav-text">곱셉을 할때 속도를 빠르게 하려면 어떻게 할 것인가</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#오버라이딩과-오버로딩의-차이-시그니처"><span class="toc-nav-text">오버라이딩과 오버로딩의 차이 (시그니처)</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#OOP-란-의존성-역전"><span class="toc-nav-text">OOP 란 (의존성 역전)</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#참조-4"><span class="toc-nav-text">참조</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#리플렉션이란"><span class="toc-nav-text">리플렉션이란</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Serialization-이란"><span class="toc-nav-text">Serialization 이란</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Set-vs-List"><span class="toc-nav-text">Set vs List</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Looper-와-Handler"><span class="toc-nav-text">Looper 와 Handler</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#메인-스레드가-아닌-스레도에도-루퍼가-있는가-어떻게-만들-수-있나"><span class="toc-nav-text">메인 스레드가 아닌 스레도에도 루퍼가 있는가? 어떻게 만들 수 있나?</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Looper-quit-와-quitsafely-차이"><span class="toc-nav-text">Looper.quit() 와 quitsafely 차이</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#새로운-안드로이드-버전-특징-8"><span class="toc-nav-text">새로운 안드로이드 버전 특징 (8 ~)</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#안드로이드-4대-컴포넌트"><span class="toc-nav-text">안드로이드 4대 컴포넌트</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Intent-Flag-설명-SingleTop-ClearTop"><span class="toc-nav-text">Intent Flag 설명 (SingleTop, ClearTop)</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Context-란"><span class="toc-nav-text">Context 란</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Java-8에-추가된-것들"><span class="toc-nav-text">Java 8에 추가된 것들</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#메인스레드에-대해-설명"><span class="toc-nav-text">메인스레드에 대해 설명</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#MVC-MVP-MVVM"><span class="toc-nav-text">MVC, MVP, MVVM</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#SparseArray-와-HashMap-차이"><span class="toc-nav-text">SparseArray 와 HashMap 차이</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#TedPermission-작동-원리"><span class="toc-nav-text">TedPermission 작동 원리</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#이벤트-버스란-대체할-것은"><span class="toc-nav-text">이벤트 버스란? 대체할 것은?</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#LRU-cache"><span class="toc-nav-text">LRU cache</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#버터나이프-뷰인젝터-만들어지는-과정"><span class="toc-nav-text">버터나이프, 뷰인젝터 만들어지는 과정</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#액티비티와-프래그먼트-차이"><span class="toc-nav-text">액티비티와 프래그먼트 차이</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://hyeonu1258.github.io/2018/04/01/안드로이드 면접2/';
    var banner = 'undefined'
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "hyeonu1258";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "안드로이드 면접2",
        owner: "hyeonu1258",
        repo: "hyeonu1258.github.io",
        oauth: {
          client_id: "058b1d67f791e1b7bb00",
          client_secret: "fbfb73021f7786a1b20ae6d48e54af20534d8c4e"
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2018 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>
  </body>
</html>