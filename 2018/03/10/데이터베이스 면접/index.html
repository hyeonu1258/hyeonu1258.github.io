<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="Hyeonu&#39;s blog">
  <meta name="keyword" content="android, java, kotlin">
  <title>
    
      데이터베이스 면접 | 현우의 개발노트
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
</head>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>현우의 개발노트</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>데이터베이스 면접</h2>
  <p class="post-date">2018-03-10</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body">
  <article class="post-article">
    <section class="markdown-content"><ul>
<li><strong>키(key)의 종류와 개념 설명 ?</strong><ul>
<li>키는 테이블에서 행들을 구별할 수 있는 속성 또는 속성들의 집합을 말합니다. 특징으로 모든 행에서 유일값을 가져야하는 유일성, 최소한의 속성들로만 키를 구성하는 최소성이 있습니다. 대표적으로 슈퍼키, 후보키, 기본키, 대체키, 외래키가 있습니다.<ul>
<li><strong>슈퍼키 ?</strong><ul>
<li>유일성을 만족하는 키, 즉 고유하게 식별하는 모든 조합을 슈퍼키라고 합니다.</li>
</ul>
</li>
<li><strong>후보키 ?</strong><ul>
<li>기본키로 선정될 수 있는 후보라는 의미로 유래된 이름이며, 유일성과 최소성을 만족하는 키입니다.</li>
<li><strong>슈퍼키와 후보키의 차이점 ?</strong><ul>
<li>슈퍼키의 조합에서 더 줄일 수 없이 꼭 필요한 키로 구성된 조합을 후보키라고 합니다. 예를 들어 ‘마을ID’, ‘도시명’, ‘도명’이 있는 테이블에 {마을ID, 도시명, 도명} 으로 구성된 키는 슈퍼키가 될수 있으며, {마을ID}, {도시명, 도명}이 후보키가 될 수 있습니다.</li>
</ul>
</li>
</ul>
</li>
<li><strong>기본키 ?</strong><ul>
<li>후보키 중에서 설계자에 의해 선택된 키입니다.</li>
</ul>
</li>
<li><strong>대체키 ?</strong><ul>
<li>후보키 중에서 기본키로 선택되지 못한 키입니다.</li>
</ul>
</li>
<li><strong>외래키 ?</strong><ul>
<li>다른 테이블의 기본키를 참조하는 속성을 외래키라고 합니다.<br><img src="https://mblogthumb-phinf.pstatic.net/20151215_173/hj_veronica_1450161230641pj2HE_JPEG/4.png?type=w800" alt="키 종류"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>데이터베이스 무결성에 대하여 설명 ?</strong><ul>
<li>무결성이란 데이터의 정확성과 일관성을 유지하고 보증하는 규칙을 말합니다. 데이터베이스의 무결성에는 엔티티 무결성, 참조 무결성, 도메인 무결성이 있습니다.</li>
<li><strong>엔티티 무결성 ?</strong><ul>
<li>기본키와 관련된 규칙으로, 모든 테이블은 기본키를 가져야하며 기본키는 고유하고, null이 아니어야 하는 규칙을 말합니다.</li>
</ul>
</li>
<li><strong>참조 무결성 ?</strong><ul>
<li>외래키와 관련된 규칙으로, 모든 외래키의 값이 특정 테이블의 기본키 값을 참조하거나, null 값이어야 하는 규칙을 말합니다. 예를 들어 참조하고 있는 기본키가 삭제되었을 경우 존재하지 않는 기본키를 참조하게 되므로 참조 무결성에 위배됩니다.</li>
</ul>
</li>
<li><strong>도메인 무결성 ?</strong><ul>
<li>속성 값과 관련된 규칙으로, 같은 속성의 값들은 같은 성격을 가진 값들이어야 하는 규칙입니다. 성격이란 null 값 허용여부나 자료형 등을 말할 수 있습니다.</li>
</ul>
</li>
</ul>
</li>
<li><strong>데이터베이스 정규화 설명, 왜하고 어떻게 하는지, 그리고 역정규화는 무엇인지, 왜하는지 ?</strong><ul>
<li>관계형 데이터베이스에서 데이터 중복을 최소화하고 데이터를 구조화하는 것을 정규화라고 합니다. 정규화 과정으로는 대표적으로 제 1정규형, 제 2정규형, 제 3 정규형이 있습니다.</li>
<li><strong>제 1 정규형 ?</strong><ul>
<li>테이블의 한 셀이 복합적인 값을 가지지 않는 상태를 제 1 정규형이라고 합니다. 여기서 셀은 하나의 튜플이 가지는 속성값을 말하며, 복합적인 값은 배열 값을 의미합니다.</li>
</ul>
</li>
<li><strong>제 2 정규형 ?</strong><ul>
<li>테이블에서 부분함수 종속이 없는 상태를 제 2 정규형이라고 합니다. 여기서 함수 종속은 기본키라는 입력에 유일한 속성이 출력되는 관계가 성립되면 마치 함수와 같다하여 함수 종속이라 말하는 것이며 여기서 기본키를 결정자, 속성을 종속자라 지칭 합니다. 따라서 부분함수 종속은 기본키를 구성하는 속성 일부에만 함수 종속이 존재하는 것을 말합니다. 그렇기에 기본키가 하나뿐인 테이블을 자동적으로 제 2 정규형을 만족하게 됩니다.</li>
<li><strong>부분함수 종속이 안 좋은 이유 ? or 제 2 정규형이 필요한 이유 ?</strong><ul>
<li>첫 번째로 테이블이 가지는 개념의 혼란을 일으킵니다. 부분함수 종속이 존재한다는 의미는 한 테이블 안에 카테고리가 다른 집합들이 혼재되어 있다는 뜻이 되기에 테이블을 나누어야 합니다. 두 번째로 갱신 이상을 야기합니다. 테이블이 올바른 집합 단위로 규정되어 있지 않기 때문에 각 속성의 값을 어느정도 알고 있어야만 등록이 가능할뿐더러, 기본키를 구성하는 속성이 각 행에 대하여 불필요하게 반복됨으로써 일부가 잘못 등록될 위험이 있습니다. </li>
</ul>
</li>
</ul>
</li>
<li><strong>제 3 정규형 ?</strong><ul>
<li>제 2 정규형에서 추이함수 종속을 제거한 상태를 제 3 정규형이라고 합니다.  추이 함수 종속이란 기본키이외의 속성과 다른 속성간 함수 종속이 존재하는 것을 말합니다.</li>
<li><strong>추이함수 종속이 안 좋은 이유 ? or 제 3 정규형이 필요한 이유 ?</strong><ul>
<li>추이함수로 인한 갱신이상 때문입니다. 추이함수 종속에서 종속자에 해당하는 속성값은 마음대로 갱신이 안되고 결정자인 속성 값에 따라 값이 좌우되기 때문에 이를 무시하고 데이터를 갱신한다면 이상이 발생합니다. 결국 부분함수 종속과 마찬가지로 계층이 다른 집합들을 하나의 테이블로 관리하려는 설계 문제를 내포하기에 테이블을 나누어야 문제를 해결할 수 있습니다.</li>
</ul>
</li>
</ul>
</li>
<li><strong>역정규화란 ?</strong><ul>
<li>역정규화는 데이터의 정합성이 보증되지 않더라도 속도의 향상을 위해 정규화를 위배하는 행위를 말합니다. 정규화 된 테이블은 빈번한 join를 당하게 되는게 이것은 성능을 크게 저하시키는 요소입니다. 역정규화를 하면 중복된 데이터가 발생하고 데이터의 정합성을 헤치게 되더라도 그만큼 성능을 높일 수 있는 이점이 있습니다. 허나 품질저하, 테이블 성격 불명확, 용량 증가등의 단점이 있습니다.<blockquote>
<h5 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h5><p><a href="http://geniusjo.tistory.com/entry/%EB%B0%98%EC%A0%95%EA%B7%9C%ED%99%94%EC%99%80-%EC%84%B1%EB%8A%A5" target="_blank" rel="external">반정규화의 사용배경과 적용방법</a><br><a href="http://wiki.gurubee.net/pages/viewpage.action?pageId=28606676" target="_blank" rel="external">비정규화 단점과 과정</a></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>데이터베이스 이상이란 ?</strong><ul>
<li>데이터 간 종속성, 일관성이 비논리적으로 설계되어 데이터 변경시 부작용을 일으키는 현상을 말합니다.</li>
<li><strong>삽입 이상 ?</strong><ul>
<li>데이터를 삽입해야 될 경우 원치 않는 데이터까지 삽입해야되는 현상을 말합니다. 예를 들어 학생 테이블에 학번과, 수강과목이 속성으로 있을 경우 새로운 과목이 생겨 테이블에 추가하더라도 수강 중인 학생의 학번이 불필요하게 추가되어야하는 문제가 발생합니다.</li>
</ul>
</li>
<li><strong>삭제 이상 ?</strong><ul>
<li>데이터를 삽입해야 될 경우 원치 않는 데이터까지 삭제해야되는 현상을 말합니다. 예를 들어 학생테이블에서 과목이 폐강될 경우 강의를 듣고 있던 학생에 대한 데이터 모두 삭제되어야 하는 문제가 발생합니다.</li>
</ul>
</li>
<li><strong>갱신 이상 ?</strong><ul>
<li>데이터의 일관성이 유지되지 않는 현상을 말합니다. 학생 테이블에서 학년을 변경하였는데 수강한 과목의 필요학년과 안 맞는 경우 데이터의 일관성이 유지되지 않는 문제가 발생합니다.</li>
</ul>
</li>
</ul>
</li>
<li><strong>데이터베이스 트랜잭션에 대하여 설명, ACID에 대해 설명 ?</strong><ul>
<li>트랜잭션이란 복수 쿼리를 하나의 단위로 묶어서 실행하는 것을 말합니다. 트랜잭션을 제대로 수행하기 위해서는 ACID 라는 특성을 만족하야 합니다.<ul>
<li><strong>Atomicity ?</strong><ul>
<li>일련의 쿼리가 전부 성공할지 실패할지를 보증하는 구조로서, 중간에 쿼리가 실패하여 Rollback 을 통해 처음으로 돌아가고, 모든 쿼리가 성공하면 Commit 을 통해 실행을 확정함으로써 보증하게 됩니다.</li>
</ul>
</li>
<li><strong>Consistency ?</strong><ul>
<li>일련의 쿼리 전후로 상태를 유지하는 것을 말합니다. 데이터 별로 제약이 있다면 예를 들어 유니크 제약이 걸린 데이터일 경우 일련의 쿼리가 종료된 후에도 유니크 제약에 만족해야 하는 일관성을 가져야 합니다.</li>
</ul>
</li>
<li><strong>Isolation ?</strong><ul>
<li>일련의 쿼리를 동시에 실행해도 각각의 처리가 모순없이 실행되는 것을 보증하는 것을 말합니다. 이것을 보증하기 위해 lock 걸어 후속처리를 블록하는 방법이 있으며, 단위에 따라 테이블 전체, 블록, 행 단위 lock 방식이 있습니다. 하지만 격리화(isolation)는 성능저하를 유발하기 때문에 격리 수준에 따라 Read Uncommitted, Read Committed, Repeatable Read, Serializable 로 구분되며 격리 수준에 따라 Dirty Read, Non-Repeatable Read, Phantom Read 등의 문제점이 발생할 수 있습니다.<ul>
<li><strong>Dirty Read ?</strong><ul>
<li>선행한 트랜잭션이 커밋하지 않은 상태에서 데이터를 수정 중 일때 후행하는 트랜잭션이 해당 데이터를 읽을 경우 잘못된 데이터를 읽게 되는 문제를 말합니다.</li>
</ul>
</li>
<li><strong>Non-Repeatable Read ?</strong><ul>
<li>선행하는 트랜잭션이 읽고 있는 데이터를 후행하는 트랜잭션이 접근하여 값을 변경할 때 선행한 트랜잭션은 잘못된 데이터를 읽게되는 문제를 말합니다.</li>
</ul>
</li>
<li><strong>Phantom Read ?</strong><ul>
<li>후행하는 트랜잭션이 새로운 데이터를 추가 또는 삭제하여 선행하는 트랜잭션이 데이터를 다시 읽을 때 새로운 데이터를 읽거나 이전에 읽었던 데이터가 사라지는 문제를 말합니다. 이는 데이터가 사라졌다 나타나는 등의 모습이 유령 같다하여 붙여진 이름입니다.</li>
</ul>
</li>
<li><strong>Read Uncommitted ?</strong><ul>
<li>선행하는 트랜잭션이 데이터를 변경 중일때 다른 트랜잭션이 해당 데이터를 읽을 수 있는 방식입니다. 동시성 처리 성능이 제일 좋은 반면 Dirty Read, Non-Repeatable Read, Phantom Read 문제가 발생할 수 있습니다. </li>
</ul>
</li>
<li><strong>Read Committed ?</strong><ul>
<li>선행하는 트랜잭션이 데이터를 변경할 때 후행하는 트랜잭션은 커밋이 완료된 데이터만 읽기 접근이 가능한 방식입니다. 변경 중인 데이터를 읽는 것을 막음으로써 Dirty-Read 를 예방하지만 Non-Repeatable Read, Phantom Read 문제가 발생할 수 있습니다.</li>
</ul>
</li>
<li><strong>Repeatable Read ?</strong><ul>
<li>동일한 트랜잭션 내에서 한번이라도 조회한 데이터는 트랜잭션이 끝날때까지 변경 불가하도록 설정하여 반복 조회시에도 같은 데이터가 조회됨을 보장하는 방법입니다. Non-Repeatable Read 의 문제는 해결하지만 새로운 데이터의 추가와 삭제는 가능하기에 Phantom Read 문제가 발생할 수 있습니다.</li>
</ul>
</li>
<li><strong>Serializable ?</strong><ul>
<li>선행한 트랜잭션이 종료된 후 다른 트랜잭션이 실행됩니다. 이때는 새로운 데이터의 추가 및 삭제가 불가하기에 Phantom Read 문제가 해소됩니다. 하지만 가장 엄격한 격리수준이라서 격리 문제는 발생하지 않지만 성능이 급격히 떨어집니다.<blockquote>
<h5 id="참조-1"><a href="#참조-1" class="headerlink" title="참조"></a>참조</h5><p><a href="http://kuaaan.tistory.com/98" target="_blank" rel="external">격리 수준 및 문제 설명</a><br><a href="http://egloos.zum.com/sweeper/v/3005129" target="_blank" rel="external">격리 문제 자세히 설명</a></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>Durability ?</strong><ul>
<li>일련의 쿼리가 실행완료되었다면 해당 결과는 데이터베이스에 반영되어 영구히 지속되는 것을 말합니다.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>NoSQL과 RDBMS가 뭔지 설명 ?</strong><ul>
<li>NoSQL과 RDBMS는 데이터베이스 종류 중 하나입니다. 데이터 보존 형식에 따라 구분이 되는데 RDBMS는 2차원 표형식으로 데이터를 관리하는 데이터베이스이며, NoSQL은 ‘Not Only SQL’의 준말로써, 관계형 데이터베이스 특성 뿐만 아니라 여러 특성을 가지는 확장성 높은 데이터베이스입니다.<ul>
<li><strong>RDBMS ?</strong><ul>
<li>2차원 표 형태로 데이터를 관리하는 데이터베이스로서, 친근한 구조로 인해 사람에게 자연스럽고 직관적인 이해를 할 수 있는 특징이 있습니다. 또한 프로그래밍 언어를 몰라도 데이터를 쉽게 조작할 수 있도록 설계된 언어인 SQL을 통하여 데이터 조작을 할 수 있어 편리하단 장점이 있습니다. 하지만 데이터의 일관성을 엄격히 준수하고 중복을 최소화하는 특징에 의해 속도가 비교적 느리고, 유연성이 낮습니다. 따라서 데이터를 수많은 서버에 분산 저장하는 data sharding이 어려워 서버 확장이 힘들다는 단점이 있습니다.</li>
</ul>
</li>
<li><strong>NoSQL ?</strong><ul>
<li>빅데이터에서 쏟아져 나오는 방대한 양의 비정형 데이터를 처리하기 위해 설계된 데이터베이스로서 기존의 RDB는 정형화된 데이터만 처리할 수 있는 문제 때문에 빅데이터 환경에서 이를 대처하기 위해 사용되었습니다. 데이터의 일관성을 보장하지 않는 대신 빠른 속도를 가지고, schema-less 구조이기에 유연성이 높습니다. 데이터의 중복을 허용하는 구조때문에 scale out 방식 중 하나인 sharding 적용이 쉬워 서버 확장이 쉽다는 특징을 가집니다. 하지만 결국 데이터 손실 위험을 있고, 복잡한 join이 어렵다는 단점이 있습니다.<blockquote>
<h5 id="참조-2"><a href="#참조-2" class="headerlink" title="참조"></a>참조</h5><p><a href="http://lazybrain.ikspres.com/nosql1/" target="_blank" rel="external">NoSQL 장단점</a><br><a href="https://blog.outsider.ne.kr/519" target="_blank" rel="external">NoSQL 배경과 개념 그리고 CAP 이론</a><br><a href="http://asfirstalways.tistory.com/66" target="_blank" rel="external">Scale out 과 Sharding</a></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>data independency란 ?</strong><ul>
<li>데이터베이스 관리 시스템의 목적은 데이터의 논리적 구조나 물리적 구조가 변경되더라도 어플리케이션에 영향을 미치지 않는 것입니다. 그리고 이것을 데이터 독립성이라고 합니다. 데이터의 논리적 물리적 연결 구조의 추상화를 통하여 계층별 독립성을 가능케합니다. 이를 통해서 데이터베이스 관리자는 응용 프로그램을 수정하지 않고도 데이터의 구조를 변경할 수 있으며, 데이터 처리 관련 소프트웨어나 하드웨어 변경시에도 응용 프로그램에 영향을 끼치지 않을 수 있게 됩니다. 데이터 독립성의 종류로 논리적 데이터 독립성과 물리적 데이터 독립성이 있습니다.<ul>
<li><strong>논리적 데이터 독립성 ?</strong><ul>
<li>데이터베이스의의 논리적 구조를 개념 스키마라고 합니다. 따라서 논리적 데이터 독립성이란 테이블의 개념 스키마가 변경되더라도 기존 어플리케이션에 영향을 주지 않고 변경시킬 수 있는 속성을 말합니다.</li>
<li><strong>물리적 데이터 독립성 ?</strong><ul>
<li>물리적인 데이터 구조를 내부 스키마라고 하며 내부 스키마가 변경되어도 기존 어플리케이션의 수정을 요하지 않고 물리적 구조를 변경할 수 있는 속성을 물리적 데이터 독립성이라고 합니다.<br><img src="http://cfile25.uf.tistory.com/image/226B2F4353947AF6082EE4" alt="데이터베이스 스키마 종류"><blockquote>
<h5 id="참조-3"><a href="#참조-3" class="headerlink" title="참조"></a>참조</h5><p><a href="https://m.blog.naver.com/PostView.nhn?blogId=ageofgaya&amp;logNo=130019550380&amp;proxyReferer=https%3A%2F%2Fwww.google.co.kr%2F" target="_blank" rel="external">데이터 독립성 설명</a><br><a href="http://npcore.tistory.com/70" target="_blank" rel="external">데이터베이스 스키마 설명</a></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>Trigger의 역할 ?</strong><ul>
<li>테이블에 대한 이벤트에 반응하여 자동으로 실행되는 작업을 말합니다. 여기서 이벤트는 특정 행이나 속성 전체에 INSERT, UPDATE, DELETE 가 발생할 때는 말합니다.<blockquote>
<h5 id="참조-4"><a href="#참조-4" class="headerlink" title="참조"></a>참조</h5><p><a href="http://infodbbase.tistory.com/56" target="_blank" rel="external">트리거 코드 설명</a><br><a href="https://technet.tmaxsoft.com/upload/download/online/tibero/pver-20150504-000001/tibero_dev/ch03.html" target="_blank" rel="external">트리거 구성 및 설명</a></p>
</blockquote>
</li>
</ul>
</li>
<li><strong>Join의 종류에 대해 아는대로 설명 ?</strong><ul>
<li>2개 이상의 테이블에서 필요한 값들을 하나의 테이블로 보기위해 사용하는 명령어입니다. join에는 조건에 만족하지 않는 행을 포함하느냐에 따라 내부조인과 외부조인으로 나눌 수 있습니다.</li>
<li><strong>내부 조인 ?</strong><ul>
<li>내부 조인은 조건에 만족하는 행들만 보여주는 것을 내부조인이라고 합니다.</li>
</ul>
</li>
<li><strong>외부 조인 ?</strong><ul>
<li>외부 조인은 조건에 만족하지 않는 기준 테이블의 행 또한 포함하여 보여주는 것을 외부조인이라고 하며, 기준 테이블을 왼쪽 테이블에 두면 left, 오른쪽에 두면 right라 말합니다.</li>
</ul>
</li>
</ul>
</li>
<li><strong>index ? 쓰는 이유와 장단점</strong><ul>
<li>테이블의 읽기속도를 높이기 위해 사용되는 자료구조로서 테이블의 컬럼 인덱스를 설정하여 검색시 full scan이 아닌 index 파일 검색으로 검색속도를 빠르게 합니다.<ul>
<li><strong>장점 ?</strong><ul>
<li>테이블 검색과 정렬 속도를 향상시킵니다. 또한 index를 기본키로 자동설정하여 관리가 편합니다.</li>
</ul>
</li>
<li><strong>단점 ?</strong><ul>
<li>인덱스 파일을 별도로 만들어야함으로 파일의 크기가 늘어나고 인덱스를 처음에 생성하는데 시간이 많이 소요될 수 있습니다. 또한 인덱스된 컬럼값이 변경되거나 인덱스를 업데이트해야하기에 성능이 떨어지게 됩니다.</li>
</ul>
</li>
<li><strong>인덱스를 사용해야 될 때</strong><ul>
<li>위와 같은 단점에 따라 변경이 잦은 컬럼에는 인덱싱을 피하고, true/false 값을 같는 컬럼처럼 중복도가 높은 컬럼은 인덱스로 만들어도 고유성이 없기에 효용이 없습니다. where절과 join, order by 등에 자주 사용되는 컬럼의 경우 인덱스로 선정하면 검색 속도를 효과적으로 높일 수 있습니다.</li>
</ul>
</li>
<li><strong>인덱스 구조 ?</strong><ul>
<li>검색의 효율을 높이기 위해 B-tree 또는 B+tree 구조를 사용합니다.</li>
<li><strong>B-Tree란 ?</strong><ul>
<li>==B-Tree는 검색성능을 높이기 위한 Balanced-Tree 자료구조의 종류 중 하나로서 이진트리와 다르게 하나의 노드에 여러자료가 배치되고 2개이상의 자식노드를 가질 수 있는 Tree 구조입니다.== 루트를 제외한 모든 노드의 자료수는 LIMIT/2개여야하며, 자식노드의 수는 (부모노드의 자료수 + 1)개여야하는 특징이 있습니다. 이것의 이유는 B-Tree의 구조 때문에 생긴 특징입니다. ==따라서 삽입, 삭제시에도 트리 균형을 유지할 수 있는 특징과, 언제나 균등한 탐색속도를 보장하는 특징이 있지만, 트리의 균형을 유지하기 위해 복잡한 연산을 해야하며, 무엇보다 중위순회방식을 사용하기에 순회탐색이 비효율적이라는 단점이 있습니다.==<blockquote>
<h5 id="참조-5"><a href="#참조-5" class="headerlink" title="참조"></a>참조</h5><p><a href="https://www.youtube.com/watch?v=2AD13EPQAms" target="_blank" rel="external">B-Tree 구조 설명 youtube</a></p>
</blockquote>
</li>
<li><strong>B+Tree란 ?</strong><ul>
<li>B+Tree는 B-Tree에서 순회탐색의 비효율을 보완한 구조로서, 노드의 데이터들이 연결리스트로 연결되어 있어 순차적 처리가 가능하여 순회탐색이 빠릅니다. 트리의 최하단 노드에만 데이터들이 연결리스트로 정렬되어 있으며 나머지 노드들은 키값만 가지고 있는 구조입니다.<blockquote>
<h5 id="참조-6"><a href="#참조-6" class="headerlink" title="참조"></a>참조</h5><p><a href="https://www.youtube.com/watch?v=CYKRMz8yzVU" target="_blank" rel="external">B+Tree 구조 설명 youtube</a><br><a href="https://www.youtube.com/watch?v=49P_GDeMDRo" target="_blank" rel="external">B+Tree 구조 상세설명 youtube</a><br><a href="http://potatoggg.tistory.com/174" target="_blank" rel="external">B-Tree와 B+Tree 차이</a></p>
</blockquote>
</li>
</ul>
</li>
<li><strong>Balanced-Tree란 ?</strong><ul>
<li>Tree 자료형의 기본적인 구조인 이진트리는 좌우 균형이 안 맞아 비효율적이라는 단점을 가지는데 이것은 해결한 자료구조가 Balanced-Tree 구조입니다. Balanced-Tree는 한쪽으로 몰린 depth를 균일하게 재배치함으로서 모든 자식 노드들의 depth를 균일하게 합니다. 따라서 어떠한 상횡에서도 검색성능을 O(logN)까지 일관된 속도를 보장하는 구조입니다.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>Replication ?</strong><ul>
<li>리플리케이션이란 데이터베이스를 접근하는 DB서버와 데이터를 저장하는 저장소를 구성하는 하나의 세트를 복제하여 여러 세트로 구성함으로써 위험을 분산하는 구조를 말합니다. 이러한 구조를 저장소를 공유한다 하여 shared disk라고 부릅니다. 분산처리를 통해 성능 향상을 기대할 수 있는 장점이 있는 반면, 여러 데이터가 복제되어 있는 만큼 데이터의 정합성을 유지하기 어렵습니다. 따라서 갱신 주기를 어떻게 하느냐가 중요한데 이것은 성능과 데이터의 정합성에 트레이드오프 관계가 발생하는 단점이 있습니다.</li>
</ul>
</li>
<li><strong>Sharding ?</strong><ul>
<li>데이터의 정합성 문제와 갱신에 의한 성능 저하가 발생하는 shared disk의 문제를 해결하기 위해 고안된 아키텍쳐가 shared nothing이며 이 개념에 기반하여 구글에서 만든 구조가 sharding 입니다. sharding은 데이터를 여러 저장소에 분할 저장함으로써 동기화에 대한 이슈를 제거했기에 속도 또한 빠릅니다. 분할된 구조를 통해 병합 문제를 해결하였습니다. 하지만 특정 저장소에 정해진 데이터가 저장되어있기에 데이터를 찾으려면 특정 저장소를 찾아가야한다는 문제점이 있으며, 하나의 DB 서버가 다운이 되면 복구할 수가 없다는 문제가 있습니다. 이러한 문제는 커버링이라는 구성을 통해 하나의 DB 서버가 다운되었을 때 그것을 이어받아 처리하는 조치가 필요합니다.</li>
</ul>
</li>
</ul>
</section>
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#취업준비" >
    <span class="tag-code">취업준비</span>
  </a>

      </div>
    
    <div class="money-like">
      <div class="reward-btn">
        후원
        <span class="money-code">
          <span class="kakaopay-code">
            <div class="code-image"></div>
          </span>
        </span>
      </div>
      <p class="notice">이 포스트가 도움이 되었다고 생각하시면, 위의 버튼을 클릭하여 후원해주세요.</p>
    </div>
    <div class="qrcode">
      <canvas id="share-qrcode"></canvas>
      <p class="notice">이 포스트를 공유하려면 QR 코드를 스캔하세요.</p>
    </div>
    
      <div id="comments"></div>
    
  </article>
</main>

<script>
  (function () {
    var url = 'https://hyeonu1258.github.io/2018/03/10/데이터베이스 면접/';
    $('#article-banner').geopattern(url)
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png') 
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      var imageW = $(this).width()
      var imageH = $(this).height()
      
      var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
      zoom = zoom < 1 ? 1 : zoom
      zoom = zoom > 2 ? 2 : zoom
      var transY = (($(window).height() - imageH) / 2).toFixed(2)

      $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
      $('.image-view-wrap').addClass('wrap-active')
      $('.image-view-wrap img').css({
        'width': `${imageW}`,
        'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
      })
      $('html').css('overflow', 'hidden')

      $('.image-view-wrap').on('click', function() {
        $(this).remove()
        $('html').attr('style', '')
      })
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "hyeonu1258";
    if (gitmentConfig != "undefined") {
      var gitment = new Gitment({
        id: "데이터베이스 면접",
        owner: "hyeonu1258",
        repo: "hyeonu1258.github.io",
        oauth: {
          client_id: "058b1d67f791e1b7bb00",
          client_secret: "fbfb73021f7786a1b20ae6d48e54af20534d8c4e"
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2018 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine == 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>
  </body>
</html>