<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="Hyeonu&#39;s blog">
  <meta name="keyword" content="android, java, kotlin">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      안드로이드 면접 | 현우의 개발노트
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


</head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>현우의 개발노트</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>안드로이드 면접</h2>
  <p class="post-date">2018-03-26</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h4 id="View가-그려지는-과정"><a href="#View가-그려지는-과정" class="headerlink" title="View가 그려지는 과정"></a>View가 그려지는 과정</h4><p>뷰는 포커스를 얻으면 레이아웃을 그리도록 요청한다. 이때 레이아웃의 계층구조 중 루트 뷰를 제공해야한다. 따라서 그리기는 루트노드에서 시작되어 트리를 따라 전위 순회 방식으로 그려진다. 부모 뷰는 자식 뷰가 그려지기 전에(즉, 자식 뷰 뒤에) 그려지며 형제 뷰는 전위 방식에 따라 순서대로 그려진다. 레이아웃을 그리는 과정은 측정(measure)단계와 레이아웃(layout)단계를 통해 그려지게 된다.</p>
<h5 id="measure-int-widthMeasureSpec-int-heightMeasureSpec"><a href="#measure-int-widthMeasureSpec-int-heightMeasureSpec" class="headerlink" title="measure(int widthMeasureSpec, int heightMeasureSpec)"></a>measure(int widthMeasureSpec, int heightMeasureSpec)</h5><p>부모노드에서 자식노드를 경유하며 실행되며, 뷰의 크기를 알아내기 위해 호출된다. 이것은 뷰의 크기를 측정하는 것은 아니며 실제 크기 측정은 <code>onMeasure(int, int)</code>를 통해 이뤄진다. <code>measure(int, int)</code>의 내부에서는 <code>onMeasure(int, int)</code>를 호출함으로써 뷰의 크기를 알아낸다.</p>
<p>측정 과정에서는 부모 뷰와 자식 뷰간의 크기정보를 전달하기 위해 2가지의 클래스를 사용한다.</p>
<blockquote>
<h5 id="ViewGroup-LayoutParams"><a href="#ViewGroup-LayoutParams" class="headerlink" title="ViewGroup.LayoutParams"></a>ViewGroup.LayoutParams</h5><p>자식 뷰가 부모 뷰에게 자신이 어떻게 측정되고 위치를 정할지 요청하는데 사용된다. <code>ViewGroup</code>의 sub class에 따라 다른 <code>ViewGroup.LayoutParams</code>의 sub class가 존재할 수 있다. 예를 들어 <code>ViewGroup</code>의 sub class인 <code>RelativeLayout</code> 경우 자신만의 <code>ViewGroup.LayoutParams</code>의 sub class는 자식 뷰를 수평적으로 또는 수직적으로 가운데정렬을 할 수 있는 능력이 있다.</p>
<ul>
<li>숫자 (ex. android:layout_width=”320dp”)</li>
<li>MATCH_PARENT (ex.android:layout_width=”match_parent”)</li>
<li>WRAP_CONTENT (ex.android:layout_width=”wrap_content”)</li>
</ul>
<h5 id="ViewGroup-MeasureSpec"><a href="#ViewGroup-MeasureSpec" class="headerlink" title="ViewGroup.MeasureSpec"></a>ViewGroup.MeasureSpec</h5><p>부모 뷰가 자식 뷰에게 요구사항을 전달하는데 사용된다.</p>
<ul>
<li>UNSPECIFIED - 부모 뷰는 자식 뷰가 원하는 치수대로 결정한다.</li>
<li>EXACTLY - 부모 뷰가 자식 뷰에게 정확한 크기를 강요한다.</li>
<li>AT MOST - 부모 뷰가 자식 뷰에게 최대 크기를 강요한다.</li>
</ul>
</blockquote>
<h5 id="layout-int-l-int-t-int-r-int-b"><a href="#layout-int-l-int-t-int-r-int-b" class="headerlink" title="layout(int l, int t, int r, int b)"></a>layout(int l, int t, int r, int b)</h5><p>부모노드에서 자식노드를 경유하며 실행되며, 뷰와 자식뷰들의 크기와 위치를 할당할 때 사용된다. <code>measure(int, int)</code>에 의해 각 뷰에 저장된 크기를 사용하여 위치를 지정한다. 내부적으로 <code>onLayout()</code>를 호출하고 <code>onLayout()</code>에서 실제 뷰의 위치를 할당하는 구조로 되어있다.</p>
<blockquote>
<p><code>measure()</code>와 <code>layout()</code>함수는 내부적으로 각각 <code>onMeasure()</code>와 <code>onLayout()</code>함수를 호출한다. 이것은 final로 선언된 <code>measure()</code>와 <code>layout()</code> 대신 <code>onMeasure()</code>와 <code>onLayout()</code>을 구현(override)할 것을 장려하기 위해서이다.</p>
</blockquote>
<p>뷰의 <code>measure()</code>함수가 반환할때, 뷰의 <code>getMeasureWidth()</code>와 <code>getMeasureHeight()</code>값이 설정된다. 만약 자식 뷰 측정값의 합이 너무 크거나 작을 경우 다시 <code>measure()</code>함수를 호출하여 크기를 재측정한다.</p>
<blockquote>
<h5 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h5><p><a href="http://namsieon.com/339" target="_blank" rel="external">뷰가 그려지는 과정</a></p>
<p><a href="http://i5on9i.blogspot.kr/2013/02/view.html" target="_blank" rel="external">안드로이드에서 view가 어떻게 그려지는가</a></p>
<p><a href="https://developer.android.com/guide/topics/ui/how-android-draws.html" target="_blank" rel="external">안드로이드 Docs - draws views</a></p>
</blockquote>
<h4 id="View-Lifecycle"><a href="#View-Lifecycle" class="headerlink" title="View Lifecycle"></a>View Lifecycle</h4><p><img src="https://cdn-images-1.medium.com/max/800/1*abc0UlGj1myFD0eph4pZjQ.png" alt="뷰 라이프사이클"></p>
<h5 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h5><p>모든 뷰는 생성자에서 출발합니다. 생성자에서 초기화를 하고, default 값을 설정합니다. 뷰는 초기설정을 쉽게 세팅하기 위해서 <code>AttributeSet</code>이라는 인터페이스를 지원합니다. 먼저 <code>attrs.xml</code>파일을 만들고 이것을 부름으로써 뷰의 설정값을 쉽게 설정할 수 있습니다.</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*abeF4ZlAwckInuyH7MM44w.png" alt="attrs.xml"></p>
<h5 id="onAttachedToWindow"><a href="#onAttachedToWindow" class="headerlink" title="onAttachedToWindow"></a>onAttachedToWindow</h5><p>부모 뷰가 <code>addView(childView)</code>를 호출하고 나서 자식 뷰는 윈도우에 붙게 됩니다(attached). 이때부터 뷰의 id 를 통해 접근할 수 있습니다.</p>
<h5 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h5><p>뷰의 크기를 측정하는 단계입니다. 매우 중요한 단계이며, 대부분의 경우 레이아웃에 맞게 특정크기를 가져야합니다. 여기에는 두단계의 과정이 있습니다.</p>
<ol>
<li><p>뷰가 원하는 사이즈를 계산합니다.</p>
</li>
<li><p><code>MeasureSpec</code>에 따라 크기와 mode를 가져옵니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">        <span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">        <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line">        <span class="keyword">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>MeasureSpec</code>의 mode를 체크하여 뷰의 크기를 적용합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> width;</div><div class="line"><span class="keyword">if</span> (widthMode == MeasureSpec.EXACTLY) &#123;</div><div class="line">  width = widthSize;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (widthMode == MeasureSpec.AT_MOST) &#123;</div><div class="line">  width = Math.min(desiredWidth, widthSize);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  width = desiredWidth;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h5><p>이 단계에서 뷰의 크기와 위치를 할당합니다.</p>
<h5 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw"></a>onDraw</h5><p>뷰를 실제로 그리는 단계입니다. <code>Canvas</code>와 <code>Paint</code>객체를 사용하면 필요한 것을 그리게 됩니다. <code>Canvas</code>객체는 <code>onDraw</code>함수의 파라미터로 제공됩니다. <code>Canvas</code>을 이용하여 뷰의 모양을 그립니다. <code>Paint</code>객체는 뷰의 색을 그립니다. </p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*q9ihFmwrDxAkKBNBbFy7NQ.png" alt="draw"></p>
<p>여기서 주의할 점은 <strong><code>onDraw</code>함수를 호출시 많은 시간이 소요됩니다.</strong> Scroll 또는 Swipe 등을 할 경우 뷰는 다시 <code>onDraw</code>와 <code>onLayout</code>을 다시 호출하게 됩니다. 따라서 함수 내에서 객체할당을 피하고 한 번 할당한 객체를 재사용할 것을 권장합니다.</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*5lb2olkta6jeFAfvQc74mg.png" alt="onDraw내 객체할당"></p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*gRVf4dJg3vAscM6aFQsH9w.png" alt="onDraw내 객체할당2"></p>
<h5 id="View-Update"><a href="#View-Update" class="headerlink" title="View Update"></a>View Update</h5><p><em>View Lifecycle</em>을 보면 뷰를 다시 그리도록 유도하는 <code>invalidate()</code>와 <code>requestLayout()</code>함수를 볼 수 있습니다. 이것은 런타임에 뷰를 다시 그릴 수 있게 합니다. 각각의 사용 용도는 아래와 같습니다.</p>
<blockquote>
<h5 id="invalidate"><a href="#invalidate" class="headerlink" title="invalidate()"></a>invalidate()</h5><p>단순히 뷰를 다시 그릴때 사용된다. 예를 들어 뷰의 <em>text</em> 또는 <em>color</em>가 변경되거나 , <em>touch interactivity</em>가 발생할 때 <code>onDraw()</code>함수를 재호출하면서 뷰를 업데이트한다.</p>
<h5 id="requestLayout"><a href="#requestLayout" class="headerlink" title="requestLayout()"></a>requestLayout()</h5><p><code>onMeasure()</code>부터 다시 뷰의 그린다. 뷰의 사이즈가 변경될때 그것을 다시 재측정해야하기에 <em>lifecycle</em>을 <code>onMeasure()</code>부터 순회하면서 뷰를 그린다.</p>
</blockquote>
<h5 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h5><p>뷰의 <em>animation</em>은 <em>frame</em>단위의 프로세스입니다. 예를 들어 뷰가 점점 커질때 뷰를 한 단계씩 차례대로 커지도록 할 것입니다. 그리고 각 단계마다 invalidate()를 호출하여 뷰를 그릴 것입니다. 대표적으로 애니메이션에 사용하는 클래스는 <code>ValueAnimator</code>입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ValueAnimator animator = ValueAnimator.ofInt(<span class="number">0</span>, <span class="number">100</span>);</div><div class="line">animator.setDuration(<span class="number">1000</span>);</div><div class="line">animator.setInterpolator(<span class="keyword">new</span> DecelerateInterpolator());</div><div class="line">animator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> newRadius = (<span class="keyword">int</span>) animation.getAnimatedValue();</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">animator.start();</div></pre></td></tr></table></figure>
<blockquote>
<h5 id="참조-1"><a href="#참조-1" class="headerlink" title="참조"></a>참조</h5><p><a href="https://medium.com/romandanylyk96/android-draw-a-custom-view-ef79fe2ff54b" target="_blank" rel="external">Media - draw a custom view</a></p>
</blockquote>
<h4 id="Activity-Lifecycle"><a href="#Activity-Lifecycle" class="headerlink" title="Activity Lifecycle"></a>Activity Lifecycle</h4><p><img src="https://kairo96.gitbooks.io/android/content/pic2/2-4-1-1.jpg" alt="액티비티 생명주기"></p>
<h5 id="onCreate"><a href="#onCreate" class="headerlink" title="onCreate"></a>onCreate</h5><p>액티비티가 처음 생성되었을 때 호출된다. 여기서 일반적인 정적 설정을 모두 수행해야 하며 이전 상태(intent)가 캡쳐된 경우 이것을 포함한 번들 객체가 전달된다. 항상 뒤에는 <code>onStart</code>가 따라온다.</p>
<h5 id="onRestart"><a href="#onRestart" class="headerlink" title="onRestart"></a>onRestart</h5><p>액티비티가 중단되었다가 다시 시작되기 직전에 호출된다. 항상 뒤에는 <code>onStart</code>가 따라온다.</p>
<h5 id="onStart"><a href="#onStart" class="headerlink" title="onStart"></a>onStart</h5><p>액티비티가 사용자에게 보여지기 직전에 호출된다. 액티비티가 전경으로 나오면 <code>onResume</code>이 따라오고 액티비티가 숨겨지면 <code>onStop</code>이 따라온다.</p>
<h5 id="onResume"><a href="#onResume" class="headerlink" title="onResume"></a>onResume</h5><p>액티비티가 화면에 보여지고 사용자와 상호작용하기 직전에 호출된다. 이 시점에 액티비티는 액티비티스택  최상단에 위치한다. 항상 뒤에는 <code>onPause</code>가 뒤따라온다.</p>
<h5 id="onPause"><a href="#onPause" class="headerlink" title="onPause"></a>onPause</h5><p>다른 액티비티로 넘어가거나, 뒤로 가기를 누르거나, 홈으로 돌아가는 등 현재 액티비티가 사라지기 직전에 호출된다. 데이터를 유지하기 위해 저장하거나 스레드 중지 또는 앱이 종료되기 직전에 실행할 기능 등을 처리하기에 적당하다. <strong>무슨 일은 하든 매우 빨리 끝내야 한다. 이 함수가 반환될때까지 다음 액티비티가 재개되지 않기 때문이다.</strong> 액티비티가 다시 전경으로 돌아오면 <code>onResume</code>이 뒤따라오고, 액티비티가 보이지 않게 되면 <code>onStop</code>이 뒤따라온다.</p>
<h5 id="onStop"><a href="#onStop" class="headerlink" title="onStop"></a>onStop</h5><p>액티비티가 더이상 사용자에게 보여지지 않을 때 호출된다. 항상 호출되는 것은 아니며 메모리가 부족할 경우 호출이 안될 수 있다. <strong>액티비티가 다시 전경으로 돌아오면 <code>onRestart</code>가 뒤따라오고</strong> 액티비티가 그대로 사라지면 <code>onDestroy</code>가 뒤따라온다.</p>
<h5 id="onDestroy"><a href="#onDestroy" class="headerlink" title="onDestroy"></a>onDestroy</h5><p>액티비티가 소멸되기 직전에 호출된다. 호출이 안될 경우도 있기에 만약 액티비티가 종료되는 상황에 반드시 처리할 작업이 있다면 <code>onPause</code>에서 처리를 해야한다.</p>
<p><strong>시스템이 비상 시에 메모리를 복구해야 할 경우, <code>onStop</code>과 <code>onDestroy</code>는 호출되지 않을 수도 있다. 따라서, 중요한 영구적 데이터를 보관할 경우 <code>onPause()</code>를 사용해야한다.</strong></p>
<blockquote>
<h5 id="참조-2"><a href="#참조-2" class="headerlink" title="참조"></a>참조</h5><p><a href="https://kairo96.gitbooks.io/android/content/ch2.4.1.html" target="_blank" rel="external">액티비티 생명주기</a></p>
<p><a href="https://developer.android.com/guide/components/activities.html?hl=ko" target="_blank" rel="external">안드로이드 Docs - 액티비티</a></p>
</blockquote>
<h4 id="안드로이드에서-ENUM-사용을-자제시키는-이유"><a href="#안드로이드에서-ENUM-사용을-자제시키는-이유" class="headerlink" title="안드로이드에서 ENUM 사용을 자제시키는 이유"></a>안드로이드에서 <code>ENUM</code> 사용을 자제시키는 이유</h4><p><code>ENUM</code>의 각 값은 객체이며, 각 선언은 단순히 객체를 참조하기 위해 런타임 메모리를 사용한다. 따라서 정수 또는 문자열 상수보다 더 많은 메모리를 차지하게 된다. 게다가 단일 <code>ENUM</code>을 추가하면 최종 DEX 파일 크기를 증가시키기에 런타임시 오버헤드가 발생할 수 있고, 앱의 크기가 증가하게 된다. 안드로이드에서는 <code>ENUM</code> 대신 <code>TypeDef</code> 어노테이션을 사용한다.</p>
<blockquote>
<h5 id="참조-3"><a href="#참조-3" class="headerlink" title="참조"></a>참조</h5><p><a href="https://android.jlelse.eu/android-performance-avoid-using-enum-on-android-326be0794dc3" target="_blank" rel="external">AndroidPub - Avoid using ENUM on Android</a></p>
<p><a href="http://theeye.pe.kr/archives/1243" target="_blank" rel="external">성능향상을 위한 설계</a></p>
<p><a href="http://anitoy.pe.kr/android-enum-typedef-annotation/" target="_blank" rel="external">ENUM과 Typedef 어노테이션</a></p>
</blockquote>
<h4 id="대용량-Bitmap을-불러올-경우-메모리-문제를-해결하는-방법"><a href="#대용량-Bitmap을-불러올-경우-메모리-문제를-해결하는-방법" class="headerlink" title="대용량 Bitmap을 불러올 경우 메모리 문제를 해결하는 방법"></a>대용량 Bitmap을 불러올 경우 메모리 문제를 해결하는 방법</h4><h5 id="createScaledBitmap-Bitmap-bitmap-int-width-int-height"><a href="#createScaledBitmap-Bitmap-bitmap-int-width-int-height" class="headerlink" title="createScaledBitmap(Bitmap bitmap, int width, int height)"></a>createScaledBitmap(Bitmap bitmap, int width, int height)</h5><p>비트맵을 생성할때 작은 크기로 생성하여 메모리 사용을 줄일 수 있다. 허나 이미 원본 비트맵이 메모리에 로드되어 있어야 리사이즈된 비트맵을 생성할 수 있는 단점이 있다.</p>
<h5 id="Bitmap-Options-inSampleSize"><a href="#Bitmap-Options-inSampleSize" class="headerlink" title="Bitmap.Options.inSampleSize"></a>Bitmap.Options.inSampleSize</h5><p><code>inSampleSize</code>는 2의 지수 값만 가질 수 있으며, 2의 지수만큼 이미지를 작게만든다. <code>inSampleSize</code>크기만큼 픽셀을 건너뛰어 리사이징하기 때문에 속도가 매우 빠르다. 허나 2의 지수가 아닌 값으로는 리사이징을 못하는 단점이 있다.</p>
<p><img src="https://raw.githubusercontent.com/hyeonu1258/hyeonu1258.github.io/master/images/insamplesize.png" alt="inSampleSize"></p>
<h5 id="Bitmap-Options-inScaled-Bitmap-Options-inDensity"><a href="#Bitmap-Options-inScaled-Bitmap-Options-inDensity" class="headerlink" title="Bitmap.Options.inScaled / Bitmap.Options.inDensity"></a>Bitmap.Options.inScaled / Bitmap.Options.inDensity</h5><p>어떠한 사이즈로든 리사이징이 되고 리사이징 필터가 적용되어 더욱 정교한 리사이징이 가능하다. 하지만 추가적인 필터단계는 많은 시간소요가 발생하기에 <code>inSampleSize</code>방법에 비해 느리다. </p>
<p><img src="https://raw.githubusercontent.com/hyeonu1258/hyeonu1258.github.io/master/images/indensity.png" alt="inSampleSize"></p>
<h5 id="Combine-inSampleSize-amp-inScaled-amp-inDensity"><a href="#Combine-inSampleSize-amp-inScaled-amp-inDensity" class="headerlink" title="Combine inSampleSize &amp; inScaled &amp; inDensity"></a>Combine inSampleSize &amp; inScaled &amp; inDensity</h5><p>원하는 이미지 크기보다 2배 큰 이미지를 <code>inSampleSize</code>를 통해서 리사이징한다. (2의 지수만큼 리사이징이 가능하므로) 원하는 크기까지 <code>inScaled</code>와 <code>inDensity</code>를 이용하여 정교하게 리사이징하여 원하는 크기의 이미지를 얻는다.</p>
<h5 id="Bitmap-Options-inJustDecodeBounds"><a href="#Bitmap-Options-inJustDecodeBounds" class="headerlink" title="Bitmap.Options.inJustDecodeBounds"></a>Bitmap.Options.inJustDecodeBounds</h5><p>원본 Bitmap 객체를 생성하지 않은 채로 원본 이미지 크기를 구할시 <code>inJustDecodeBounds</code>옵션을 이용한다. 이것의 값이 true일 경우 <code>BitmapFactory.decodeFile(fileName, Options)</code>를 통해 Bitmap을 생성시 Bitmap 객체를 반환하지 않고 Bitmap 정보를 Options 객체에 담는다. 따라서 <code>Options.outWidth</code>, <code>Options.outHeight</code>를 통해 너비와 높이를 알 수 있다. 반대로 Bitmap 객체를 생성하고 싶을 경우 <code>inJustDecodeBounds</code> 값을 false로 설정하여 decode하면 객체를 반환한다.</p>
<blockquote>
<h5 id="참조-4"><a href="#참조-4" class="headerlink" title="참조"></a>참조</h5><p><a href="https://www.youtube.com/watch?v=HY9aaXHx8yA" target="_blank" rel="external">Youtube - Pre-Scaling Bitmaps</a></p>
</blockquote>
<h4 id="String-Literal"><a href="#String-Literal" class="headerlink" title="String Literal"></a>String Literal</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String str = <span class="string">"abc"</span>;</div><div class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</div></pre></td></tr></table></figure>
<p><em>literal</em>이란 쌍따옴표 안의 문자열을 말한다. 위 예제 1번처럼 <em>literal</em>을 통해 <code>String</code>객체가 생성되며, 2번과 같이 <code>new</code> 연산자를 통해 생성하는 <code>String</code>객체와는 내부적 구조가 조금 다르다. 자바에서 객체생성시 객체를 참조하는 변수(str)는 <em>Stack</em> 메모리, 객체는 <em>Heap</em> 메모리에  저장이 된다. 하지만 <em>literal</em>을 통해 생성된 <code>String</code>객체는 <em>Heap</em> 메모리에 저장이 되는 것이 아니라 별도의 공간인 <em>String Constant Pool(상수풀)</em>에 저장이 된다. <em>literal</em>은 값이 변하지 않는 <em>immutable</em> 클래스이며, 대신 이전에 생성했던 문자열을 중복 생성할시 <em>SCP</em>에서 해당 문자열을 불러와 참조하게 된다. 이 과정을 자세히 말하자면 소스파일(.java)이 .class 파일로 컴파일되고 이 파일이 JVM에 로드되면, JVM은 <em>SPC</em>에서 동일한 문자열이 있는지 확인할 것이다. 만약 동일한 문자열이 있으면 그것을 재사용하고 아닐경우 객체를 생성하며 <em>SPC</em>에 저장한다. 2번에서 <code>new</code>를 통해 <em>“abc”</em>객체를 생성하는 방법은 <em>literal</em>과 동일하다. 즉, <em>SCP</em>에서 문자열을 찾거나 새로 만들어서 이것을 참조한다. 하지만 <code>new</code> 연산자가 추가적으로 <em>Heap</em>에서 객체를 생성하여 문자열 <em>literal</em>을 참조한다. 따라서 2개의 객체가 생성되는 구조이다. </p>
<p>1번과 2번을 <code>==</code>연산자로 비교하면 <code>false</code>가 나온다. 1번 객체는 <em>SPC</em>에서 가져온 객체이고 2번 객체는 <em>Heap</em>에서 가져온 객체이기에(문자열은 <em>SPC</em>에서 참조하지만 <code>String</code>객체는 <em>Heap</em>에 존재한다.) 단순 비교로는 <code>false</code>를 출력한다. 하지만 <code>intern()</code>함수를 사용하면 <code>String</code>객체가(<em>Heap</em>에 존재하는) 참조하는 실제 문자열(<em>SPC</em>에 존재하는)을 가져올 수 있다. 따라서 결과는 <code>true</code>를 반환하게 된다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(str == str2.intern());</div></pre></td></tr></table></figure>
<p><code>intern()</code>함수는 <em>SPC</em>를 탐색해서 문자열이 존재하면 그것을 리턴하고 아니면 새로운 문자열을 <em>SPC</em>에 추가한 후 다시 반환한다. 따라서 <code>new</code>를 사용하건 <em>literal</em>을 사용하건 <code>inter()</code>함수를 사용하면 같은 문자열을 반환하게 된다.</p>
<blockquote>
<h5 id="참조-5"><a href="#참조-5" class="headerlink" title="참조"></a>참조</h5><p><a href="http://marvell.tistory.com/entry/Java-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EC%A0%90%EC%97%90%EC%84%9C-%EB%B3%B8-String" target="_blank" rel="external">메모리 관점에서 본 String</a></p>
<p><a href="https://medium.com/@joongwon/string-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EC%B0%B0-57af94cbb6bc" target="_blank" rel="external">Medium - Java String 의 메모리에 대한 고찰</a></p>
<p><a href="http://sungjinlee.blogspot.kr/2013/12/blog-post.html" target="_blank" rel="external">Java의 String 객체의 메모리 사용량</a></p>
<p><a href="http://www.java67.com/2014/08/difference-between-string-literal-and-new-String-object-Java.html" target="_blank" rel="external">Java67 - Dfference between String literal and New String object in Java</a><br>: 글 내용보다 댓글논쟁이 치열하다</p>
</blockquote>
<h4 id="Annotation-생성방법-관점프로그래밍"><a href="#Annotation-생성방법-관점프로그래밍" class="headerlink" title="Annotation 생성방법 (관점프로그래밍)"></a>Annotation 생성방법 (관점프로그래밍)</h4><p>클래스간 연관관계나 속성을 표현하기 위해 java 1.5 부터 추가되었스며, 소스 코드에 메타데이터를 표현하는 용도로 사용되었습니다. <code>Annotatino</code>에는 Java에 내장되어 있는 <em>Built-in Annotation</em>, <code>Annotation</code>에 사용되는 <code>Annotation</code>인 <em>Meta-Annotation</em>, 자신의 새로 정의하는 <em>Custom Annotation</em>이 있다.</p>
<h5 id="Built-in-Annotation"><a href="#Built-in-Annotation" class="headerlink" title="Built-in Annotation"></a>Built-in Annotation</h5><p>Java에 내장되어 있으며 주로 컴파일러에게 정보를 제공하기 위한 목적으로 사용된다.</p>
<ul>
<li>@Override <ul>
<li>컴파일러에게 오버라이딩을 명시적으로 알림으로서 잘못된 메소드를 오버라이딩할 시 에러를 통해 알 수 있다.</li>
</ul>
</li>
<li>@Deprecated<ul>
<li>더 이상 사용하지 말아야할 메소드를 나타낸다.</li>
</ul>
</li>
<li>@SupressWarning<ul>
<li>의도적으로 경고 메세지를 무시하도록 컴파일러에게 알린다.</li>
</ul>
</li>
<li>FunctionalInterface<ul>
<li>함수형 인터페이스라는 것을 알림으로써 실수를 미연에 방지하도록 한다.</li>
</ul>
</li>
</ul>
<h5 id="Meta-Annotation"><a href="#Meta-Annotation" class="headerlink" title="Meta-Annotation"></a>Meta-Annotation</h5><p><code>Annotation</code>에 대해 정보를 설정하기 위한 <code>Annotation</code>이다.</p>
<ul>
<li>@Target<ul>
<li><code>Annotation</code>의 적용대상을 지정한다.</li>
</ul>
</li>
<li>@Retention<ul>
<li><code>Annotation</code>의 유지기간을 지정한다.</li>
<li><strong>SOURCE</strong> - 소스파일에만 존재하며 컴파일 시점(클래스 파일)에서는 사라진다.</li>
<li><strong>CLASS</strong> - 클래스 파일에 존재하고 컴파일러에 의해 사용가능하지만 런타임시에는 사라지기에 JVM에서 사용이 불가하다. <code>Retention</code>의 <code>default</code>값이다.</li>
<li><strong>RUNTIME</strong> - 클래스 파일에 존재하며 런타임시에도 사용 가능하다. 런타임시 <code>Reflection</code>을 통해 <code>Annotation</code>정보를 읽어 처리할 수 있다.</li>
</ul>
</li>
<li>@Documented<ul>
<li><code>Annotation</code>에 대한 정보가 javadoc에 포함되도록 한다.</li>
</ul>
</li>
<li>@Inherited<ul>
<li><code>Annotation</code>이 자식 클래시에도 상속된다. 자식 클래시에도 이 <code>Annotation</code>이 붙은 것으로 인식된다.</li>
</ul>
</li>
</ul>
<h5 id="Custom-Annotation"><a href="#Custom-Annotation" class="headerlink" title="Custom Annotation"></a>Custom Annotation</h5><p><code>@interface</code>를 통해 <code>Annotation</code>을 정의할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line">	<span class="meta">@Inherited</span></div><div class="line">	<span class="meta">@Documented</span></div><div class="line">	<span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.METHOD&#125;)</div><div class="line">	<span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line">	<span class="keyword">public</span> <span class="meta">@interface</span> MyAnno &#123;</div><div class="line">		<span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "My Annotation!"</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">		<span class="meta">@MyAnno</span>(<span class="string">"This is Sample"</span>)</div><div class="line">		<span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">			<span class="keyword">this</span>.name = name;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="keyword">return</span> name;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</div><div class="line">		MyClass my = <span class="keyword">new</span> MyClass(<span class="string">"Austen"</span>);</div><div class="line">		System.out.println(my.getName());</div><div class="line"></div><div class="line">		Field[] fields = my.getClass().getDeclaredFields();</div><div class="line">		<span class="keyword">for</span> (Field field : fields) &#123;</div><div class="line">			MyAnno anno = field.getAnnotation(MyAnno.class);</div><div class="line">			<span class="keyword">if</span> (anno != <span class="keyword">null</span> &amp;&amp; field.getType() == String.class) &#123;</div><div class="line">				field.setAccessible(<span class="keyword">true</span>);</div><div class="line">				field.set(my, anno.value());</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		System.out.println(my.getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>예제에서 선언한 <code>MyAnno</code>는 <code>Custom Annotation</code>이다. <code>Field</code>로 <code>String</code>을 가지고 있다. <code>Retention</code>을 <em>Runtime</em>으로 선언함으로서 런타임시에도 사용가능하도록 하였으며 <code>Target</code>을 <code>Field</code>와 <code>Method</code>로 설정함으로써 멤버변수와 함수에 적용가능하도록 설정하였다. <code>main</code>함수를 보면 <code>MyClass</code>의 <code>name</code>멤버변수에 <code>MyAnn Annotation</code>을 적용하였다. <code>my</code>객체의 최초 <code>name</code>값은 <em>“Austen”</em>이었지만, <code>Reflection</code>을 사용하여 <code>MyAnno</code>를 통해 받아온 <code>String</code>값을 <code>name</code>변수에 적용하였더니 출력값이 <em>“This is Sample”</em>로 변경됨을 확인할 수 있다.</p>
<blockquote>
<h5 id="참조-6"><a href="#참조-6" class="headerlink" title="참조"></a>참조</h5><p><a href="http://jdm.kr/blog/216" target="_blank" rel="external">자바 어노테이션</a></p>
<p><a href="http://asfirstalways.tistory.com/309" target="_blank" rel="external">Annotation(어노테이션인가, 애너테이션인가, 애노테이션인가)</a></p>
<p><a href="https://medium.com/@ggikko/java-%EC%BB%A4%EC%8A%A4%ED%85%80-annotation-436253f395ad" target="_blank" rel="external">Medium - Java 커스텀 Annotation(Custom Annotation 만들기)</a></p>
</blockquote>
<h4 id="프로세스와-스레드의-차이"><a href="#프로세스와-스레드의-차이" class="headerlink" title="프로세스와 스레드의 차이"></a>프로세스와 스레드의 차이</h4><p>프로그램이 메모리에 올라가 실행되면 프로세스라고 부른다. 프로세스는 운영체제로부터 메모리와 CPU를 할당 받게 된다. 스레드는 프로세스 내에서 동작하는 실행 흐름을 말한다. 따라서 스레드끼리 프로세스 내의 스택을 제외한 자원을 공유할 수 있다. 기본적으로 하나의 프로세스가 실행되면 하나의 스레드가 실행된다. 이것을 메인 스레드라고 부르며, 안드로이드에서는 UI 스레드라고 부른다.</p>
<h5 id="여러-프로세스를-통해-작업을-하지-않고-스레드를-사용하는-이유"><a href="#여러-프로세스를-통해-작업을-하지-않고-스레드를-사용하는-이유" class="headerlink" title="여러 프로세스를 통해 작업을 하지 않고 스레드를 사용하는 이유"></a>여러 프로세스를 통해 작업을 하지 않고 스레드를 사용하는 이유</h5><p>첫번째, 프로세스간 자원을 공유하지 않는다. 프로세스는 자신만의 메모리영역이 존재하고 이것은 다른 프로세스에서 접근이 불가능하다. (프로세스간 자원공유 설명필요…)</p>
<p>두번째, 프로세스의 생성은 많은 자원과 메모리가 사용되므로 비용이 크다. 프로세스가 실행되려면 메모리에 올라와야하므로 비용이 크다.</p>
<p>세번째, 다른 프로세스에게 CPU를 넘기는 Context Switch는 비용이 큰 작업이고, 시스템콜을 발생시키므로 시간이 오래걸린다. </p>
<p>따라서 여러 작업을 동시에 실행하기 위해서는 여러 스레드를 사용하여 비동기적인 실행을 하는 것이 더욱 효율적이다.</p>
<blockquote>
<h5 id="참조-7"><a href="#참조-7" class="headerlink" title="참조"></a>참조</h5><p><a href="https://brunch.co.kr/@kd4/3" target="_blank" rel="external">브런치 - 프로세스와 스레드의 차이</a></p>
<p><a href="http://ralf79.tistory.com/34" target="_blank" rel="external">프로세스와 스레드의 차이</a></p>
</blockquote>
<h4 id="Vector-vs-ArrayList-vs-LinkedList"><a href="#Vector-vs-ArrayList-vs-LinkedList" class="headerlink" title="Vector vs ArrayList vs LinkedList"></a>Vector vs ArrayList vs LinkedList</h4><p><code>Vector</code>는 배열의 동적인 사용을 위해 Java 1.0 부터 제공되는 클래스이다. 내부적으로 <code>synchronized</code>를 통해 구현되어 있기 때문에 동기화를 보장한다. 하지만 멀티 스레드 환경에서는 성능이 현저히 떨어지기 때문에 <code>List</code>인터페이스를 주로 사용한다. <code>ArrayList</code>와 <code>LinkedList</code>는 <code>List</code>인터페이스를 구현한 <code>Collection</code>구현체이다. <code>List</code>인터페이스는 기본생성시 동기화를 보장하지 않지만 동기화가 필요한 환경에서는 <code>Collections</code>클래스를 통해 동기화를 보장할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Collection.synchronizedList(List&lt;T&gt; list);</div></pre></td></tr></table></figure>
<h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><p>내부적으로 데이터를 배열에서 관리하며 추가, 삭제시 임시 배열을 생성하여 데이터를 복사하는 구조이다. 따라서 대량의 자료를 추가, 삭제할 시 메모리 소모가 크고, 시간이 오래걸려 성능저하가 발생하며, 사이즈가 고정되어 있기때문에 사이즈를 초과할시 사이즈가 늘어난 배열을 생성하여 데이터를 옮겨야하기에 복잡한 연산과 메모리가 필요하다는 단점이 있습니다. 하지만 데이터마다 인덱스를 가지고 있기 때문에 검색에 뛰어나다. </p>
<h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><p>데이터를 노드에 저장하고 노드간 양방향 연결을 통해 데이터를 추가, 삭제하는 구조이다. 따라서 추가, 삭제가 빠른 장점이 있지만, 검색시 노드를 처음부터 순회해야 하기 때문에 비교적 느리다는 단점이 있다.</p>
<blockquote>
<h5 id="참조-8"><a href="#참조-8" class="headerlink" title="참조"></a>참조</h5><p><a href="https://www.holaxprogramming.com/2014/02/12/java-list-interface/" target="_blank" rel="external">Java의 LinkedList와 ArrayList에 대한 비교</a></p>
<p><a href="http://www.nextree.co.kr/p6506/" target="_blank" rel="external">자료구조:LinkedList 대 ArrayList</a></p>
</blockquote>
<h4 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h4><p>특정 원소를 <em>pivot</em>으로 설정하여 <em>pivot</em> 앞에는 작은 값, 뒤에는 큰 값들을 위치시킨다. 둘로 분할된 리스트는 각각 앞의 과정을 재귀로 반복실행하여 정렬하는 과정이다. 시간복잡도는 최악이 O(n^2)이고, 평균 O(nlogn)이다. 최악의 상황은 항상 <em>pivot</em>을 최댓값 또는 최솟값으로 선택한 경우로서 매번 정렬된 원소들이 한쪽에 치우치게 되어 비교연산을 <em>n^2</em>번 하기 때문이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</div><div class="line">    <span class="comment">// pivot을 랜덤으로 설정하기 위한 Random 객체</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random();</div><div class="line">    <span class="comment">// Stack에 탐색범위를 저장하기 위한 클래스</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Range</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Range</span>&gt; </span>&#123;</div><div class="line">		<span class="keyword">int</span> start, end;</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Range</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">			<span class="keyword">this</span>.start = start;</div><div class="line">			<span class="keyword">this</span>.end = end;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="keyword">int</span> result = <span class="number">17</span>;</div><div class="line">			result = <span class="number">31</span> * result + <span class="keyword">this</span>.start;</div><div class="line">			result = <span class="number">31</span> * result + <span class="keyword">this</span>.end;</div><div class="line">			<span class="keyword">return</span> result;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">			<span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (obj.getClass() != Range.class) &#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">			&#125;</div><div class="line">			Range that = (Range) obj;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.start == that.start &amp;&amp; <span class="keyword">this</span>.end == that.end;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Range that)</span> </span>&#123;</div><div class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.start != that.start) &#123;</div><div class="line">				<span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.start, that.start);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.end != that.end) &#123;</div><div class="line">				<span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.end, that.end);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> temp = array[left];</div><div class="line">		array[left] = array[right];</div><div class="line">		array[right] = temp;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 재귀함수</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (start &gt;= end) &#123;</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">        <span class="comment">// pivot을 랜덤으로 정함</span></div><div class="line">		<span class="keyword">int</span> pivot = random.nextInt(end - start) + start;</div><div class="line">        <span class="comment">// pivot으로 정한 값을 탐색범위의 첫번째에 위치 (정렬의 편의성을 위해 pivot을 첫번째 index에 옮김)</span></div><div class="line">		swap(start, pivot, array);</div><div class="line">		pivot = start;</div><div class="line">		<span class="keyword">int</span> division = start + <span class="number">1</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= end; i++) &#123;</div><div class="line">			<span class="keyword">if</span> (array[pivot] &gt; array[i]) &#123;</div><div class="line">				swap(division, i, array);</div><div class="line">				division++;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		swap(pivot, division - <span class="number">1</span>, array);</div><div class="line">		quick(start, division - <span class="number">2</span>, array);</div><div class="line">		quick(division, end, array);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Stack</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickStack</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">		Stack&lt;Range&gt; stack = <span class="keyword">new</span> Stack&lt;Range&gt;();</div><div class="line">		stack.push(<span class="keyword">new</span> Range(start, end));</div><div class="line">		<span class="keyword">while</span> (!stack.isEmpty()) &#123;</div><div class="line">			Range range = stack.pop();</div><div class="line">			<span class="keyword">if</span> (range.start &gt;= range.end) &#123;</div><div class="line">				<span class="keyword">continue</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">int</span> pivot = random.nextInt(range.end - range.start) + range.start;</div><div class="line">			swap(range.start, pivot, array);</div><div class="line">			pivot = range.start;</div><div class="line">			<span class="keyword">int</span> division = range.start + <span class="number">1</span>;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = range.start + <span class="number">1</span>; i &lt;= range.end; i++) &#123;</div><div class="line">				<span class="keyword">if</span> (array[pivot] &gt; array[i]) &#123;</div><div class="line">					swap(division, i, array);</div><div class="line">					division++;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			swap(pivot, division - <span class="number">1</span>, array);</div><div class="line">			stack.push(<span class="keyword">new</span> Range(range.start, division - <span class="number">2</span>));</div><div class="line">			stack.push(<span class="keyword">new</span> Range(division, range.end));</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</div><div class="line">            array[i] = random.nextInt(array.length);</div><div class="line">            <span class="comment">// 모든 원소값이 같은 값일 경우 - 재귀함수로 정렬시 StackOverFlow 발생, Stack을 사용해야함</span></div><div class="line">            <span class="comment">// array[i] = 0;</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 재귀함수를 사용하는 일반적인 방법</span></div><div class="line">        quick(<span class="number">0</span>, array.length - <span class="number">1</span>, array);</div><div class="line">        <span class="comment">// Stack을 사용하여 StackOverFlow를 방지하는 방법</span></div><div class="line">        quickStack(<span class="number">0</span>, array.length - <span class="number">1</span>, array);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h5 id="참조-9"><a href="#참조-9" class="headerlink" title="참조"></a>참조</h5><p><a href="http://zeddios.tistory.com/35" target="_blank" rel="external">정렬 알고리즘 - Quick Sort (평균 - nlogn, 최악 - n^2)</a></p>
<p><a href="https://github.com/minsuk-heo/java_coding_interview/blob/master/src/Sorts/MyQuickSort.java" target="_blank" rel="external">Git - MyQuickSort</a></p>
<p><a href="http://blog.naver.com/PostView.nhn?blogId=skout123&amp;logNo=50146057574" target="_blank" rel="external">퀵 정렬</a></p>
</blockquote>
<h4 id="다형성-Polymorphism-이란"><a href="#다형성-Polymorphism-이란" class="headerlink" title="다형성(Polymorphism)이란"></a>다형성(Polymorphism)이란</h4><p>사전적 의미로는 같은 생물종이지만 모습이나 특징이 고유한 성질을 가지는 것을 말하며, 관용적인 의미로는 클래스나 메소드가 다양한 형태로 사용되는 것을 말한다. 즉, 자바에서 다형성은 같은 객체이지만 다양하게 구현되어 각자 고유한 성질을 가지는 객체로 사용되는 것을 말한다. 대표적으로 <code>Override</code>와 <code>Overload</code>, <code>Interface</code>가 있다. 이런 관점에서 보았을때 <code>Generic</code>을 다형성으로 표현하기 어렵다.</p>
<blockquote>
<h5 id="참조-10"><a href="#참조-10" class="headerlink" title="참조"></a>참조</h5><p><a href="http://asfirstalways.tistory.com/168" target="_blank" rel="external">9. 다형성 / 객체지향적 이해, 다형성과 클래스, 다형성과 인터페이스</a></p>
</blockquote>
<h4 id="Iterator를-쓰지-않고-직접-참조-시-문제점"><a href="#Iterator를-쓰지-않고-직접-참조-시-문제점" class="headerlink" title="Iterator를 쓰지 않고 직접 참조 시 문제점"></a>Iterator를 쓰지 않고 직접 참조 시 문제점</h4><p><code>Iterator</code>는 내부 구현에 대한 이해 없이 데이터를 순차적으로 탐색할 수 있도록 지원하는 인터페이스이다. 데이터의 내부 구조를 모르더라도 <code>next()</code>함수를 통해 일관된 순차 탐색이 가능하다. <code>LinkedList</code>, <code>HashMap</code>을 구성하는 구체적인 자료구조(<code>Node</code>나 <code>Entry</code>)를 모르더라도 <code>Iterator</code>를 사용하면 원하는 정보를 가져올수 있다. 따라서 클래스의 <strong>정보은닉</strong>과 <strong>다형성</strong>을 보장한다. <code>Iterator</code>를 쓰지 않을 경우 다음과 같은 문제가 발생할 수 있다. </p>
<ul>
<li><p>내부 구조가 노출되지 않아야하는 클래스로 구성된 구성된 리스트를 탐색할때 클래스가 탐색 기능을 지원하지 않는 한 탐색이 불가능하다. (정보은닉 문제)</p>
</li>
<li><p><code>Collection</code>과 같은 인터페이스를 구현한 자료구조를 탐색할때 각각의 자료구조에 맞는 탐색 기능을 구현해야한다. (다형성 문제)</p>
</li>
<li><p>특히, <code>LinekdList</code>의 경우 데이터를 탐색할때 시간 복잡도가 O(n^2)이 나와 성능저하를 유발할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 예제</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; linkedList.size(); i++) &#123;</div><div class="line">    <span class="keyword">if</span> (linkedList.get(i) == <span class="string">"what i'm looking for"</span>) &#123;</div><div class="line">        System.out.println(<span class="string">"Get Cha"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// LinkedList.get(int index)</span></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    checkElementIndex(index);</div><div class="line">    <span class="keyword">return</span> node(index).item;</div><div class="line">&#125;</div><div class="line"><span class="comment">// LinkedList.node(int index)</span></div><div class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</div><div class="line">        Node&lt;E&gt; x = first;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</div><div class="line">            x = x.next;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Node&lt;E&gt; x = last;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</div><div class="line">            x = x.prev;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>위 예제는 <code>index</code>를 이용하여 찾고자하는 값까지 순차탐색하는 코드이다. <code>LinkedList</code>외부에서 값을 찾기위해 순차탐색을 하지만 <code>LinkedList</code> 내부에서도 해당 <code>index</code>까지 접근하기 위해 순차탐색을 하는 것을 볼 수 있다. <code>LinkedList</code>의 인덱스에 접근하기 위해서는 <code>head</code>부터 <code>index</code>까지 순차탐색을 해야하기 때문이다. 따라서 <code>LinkedList</code>는 순차탐색시 <code>iterator</code>를 이용한 접근을 해야된다. </p>
</li>
</ul>
<blockquote>
<h5 id="참조-11"><a href="#참조-11" class="headerlink" title="참조"></a>참조</h5><p><a href="http://tip.daum.net/question/69160802" target="_blank" rel="external">Daum Tip - Iterator에 대해서</a></p>
</blockquote>
<h4 id="제네릭이란"><a href="#제네릭이란" class="headerlink" title="제네릭이란"></a>제네릭이란</h4><p>클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법이다. 제네릭을 사용하는 이유는 <strong>확장성</strong>과 <strong>타입 안전성</strong> 때문이다. 기능을 구현할때 제네릭을 사용하면 다양한 자료형에 적용이 가능하여 확장성을 보장할 수 있다. 이러한 특징은 <code>Object</code>를 통해서도 보장이 가능하지만 <code>Object</code>는 타입에 대한 검사가 이뤄지지 않기 때문에 컴파일 타임에 문제를 인지할 수 없다. 따라서 잘못된 타입이 적용되었을 경우 에러를 잡기가 힘들다. 반면 제네릭은 사용하고자하는 자료형을 명시적으로 표시함으로써 잘못된 자료형을 컴파일타임에 찾을 수 있다. 비록 제네릭은 생략될 수 있기 때문에 명시적인 자료형 선언 없이도 사용이 가능하여 타입 안전성이 무너질 수 있으나 컴파일이 경고를 통해 타입 안전성이 깨진다는 메세지를 보냄으로써 문제 유발 가능성을 알 수 있다.</p>
<blockquote>
<h5 id="참조-12"><a href="#참조-12" class="headerlink" title="참조"></a>참조</h5><p><a href="https://opentutorials.org/module/516/6237" target="_blank" rel="external">생활코딩 - 제네릭</a></p>
</blockquote>
<h4 id="Singleton-동기화"><a href="#Singleton-동기화" class="headerlink" title="Singleton 동기화"></a>Singleton 동기화</h4><p>클래스에서 하나의 객체만 생성하여 사용하도록 제한하는 디자인패턴이다. 하나의 객체만 관리하여 요청을 차례대로 처리해야하는 <code>Thread Pool</code>이나 <code>Datebase Connection Pool</code> 같은 경우 사용되며 객체를 생성하는데 비용이 큰 객체의 경우, 하나의 객체를 재사용함으로써 메모리 사용을 줄이고 객체 로딩 시간을 줄일 수 있다. </p>
<h5 id="문제점"><a href="#문제점" class="headerlink" title="문제점"></a>문제점</h5><p><code>Singleton</code>객체를 사용하는 클래스간 결합도가 높아지기에 테스트가 어렵고, 에러를 잡기가 어려워진다. 또한 멀티 스레드 환경에서 데이터 동기화문제가 발생한다. 메모리 반환도 제대로 이루어지지 않기 때문에 너무 많은 사용은 오히려 메모리 소모가 많을 수 있다.</p>
<blockquote>
<h5 id="참조-13"><a href="#참조-13" class="headerlink" title="참조"></a>참조</h5><p><a href="https://softwareengineering.stackexchange.com/questions/34485/what-is-the-difference-between-all-static-methods-and-applying-a-singleton-patte" target="_blank" rel="external">What is the difference between all-static-methods and applying a singleton pattern</a></p>
<p><a href="https://javarevealed.wordpress.com/tag/eager-initialization/" target="_blank" rel="external">Singleton Design Pattern - When To Use Static Class In Place Of Singleton In Java</a></p>
</blockquote>
<h5 id="정적-클래스-메소드-와-Singleton차이"><a href="#정적-클래스-메소드-와-Singleton차이" class="headerlink" title="정적 클래스(메소드)와 Singleton차이"></a>정적 클래스(메소드)와 <code>Singleton</code>차이</h5><p><code>Singleton</code>클래스는 객체를 함수에 파라미터로 전달할 수 있고, 일반 객체처럼 다룰 수 있다. 정적 클래스는 오로지 정적 메소드에 대한 접근만 허용한다. 정적 메소드는 단순 사용만 가능하지만 <code>Singleton</code>클래스는 다른 클래스를 상속할 수 있고, 상속될 수 있어 확장성이 크다.</p>
<h5 id="Singleton-사용시-멀티-스레드-환경에서-동기화-문제-해결하기"><a href="#Singleton-사용시-멀티-스레드-환경에서-동기화-문제-해결하기" class="headerlink" title="Singleton 사용시 멀티 스레드 환경에서 동기화 문제 해결하기"></a><code>Singleton</code> 사용시 멀티 스레드 환경에서 동기화 문제 해결하기</h5><h5 id="1-Lazy-initialization-게으른-초기화"><a href="#1-Lazy-initialization-게으른-초기화" class="headerlink" title="1. Lazy initialization(게으른 초기화)"></a>1. Lazy initialization(게으른 초기화)</h5><p><code>instance</code>를 <code>private static</code>으로 선언한 후 <code>getInstance()</code>함수에 <code>synchronized</code>키워드를 적용하여 <em>thread-sate</em>하게 만든다. 하지만 <code>getInstance()</code> 접근할때마다 <code>synchronized</code>가 발생하여 성능저하를 유발한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">            instance = <span class="keyword">new</span> Singleton();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2-Lazy-initialization-Double-checked-locking"><a href="#2-Lazy-initialization-Double-checked-locking" class="headerlink" title="2. Lazy initialization + Double-checked locking"></a>2. Lazy initialization + Double-checked locking</h5><p><code>getInstance()</code>에 <code>synchronized</code>를 사용하는 것이 아니라 <code>getInstance()</code>함수 안에서 <code>if</code>문으로 <em>instance</em>존재 여부를 체크한 후 <code>null</code>이면 여기서부터 <code>synchronized</code>를 사용하여 이후 작업을 동기화시킨다. <code>synchronized</code>안에서 다시 <em>instance</em>를 <code>null</code>체크하여 객체를 생성할지 말지 결정한다. 이 방법으로 인해 처음 <code>Singleton</code>클래스가 객체 생성이후 <code>synchronized</code>코드를 타지 않기 때문에 성능저하를 완화할 수 있다. 하지만 out-of-order 쓰기로 인해 <code>null</code>을 반환할 수 있다. 이것은 객체생성시 초기화 시점으로 인한 문제인데 다음과 같은 진행으로 문제가 발생한다.</p>
<ol>
<li>첫 스레드가 <em>1번</em> 코드를 지나고 <em>2번</em> 코드에 진입한다.</li>
<li>첫번째 스레드는 다시 <em>3번</em> 코드을 지나 <em>4번</em> 코드에 의해 객체를 생성하지만 아직 <code>simbolic reference</code>단계이고 생성자를 호출하기 전에 두번째 스레드에 선점된다.</li>
<li>두번째 스레드는 <em>1번</em> 코드에서 객체를 반환받는다. <code>instance</code>는 _non<em>null</em> 상태이기에 객체를 리턴한다. 하지만 객체는 완전한 초기화가 진행되지 않은 상태의 객체이다.</li>
<li>다시 첫번째 스레드에 선점되고 초기화가 완료된 후 완전한 객체가 반환된다.</li>
</ol>
<p>이런 문제는 <code>volatile</code>로 인해 해결이 가능하지만 이 또한 성능저하가 크다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;					<span class="comment">// 1</span></div><div class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;	<span class="comment">// 2</span></div><div class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;			<span class="comment">// 3</span></div><div class="line">            		instance = <span class="keyword">new</span> Singleton();	<span class="comment">// 4</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h5 id="참조-14"><a href="#참조-14" class="headerlink" title="참조"></a>참조</h5><p><a href="http://www.mimul.com/pebble/default/2013/05/27/1369640835148.html" target="_blank" rel="external">Singleton, Lazy loading 그리고 WeakSingleton</a></p>
<p><a href="https://www.ibm.com/developerworks/library/j-dcl/" target="_blank" rel="external">Double-checked locking and the Singleton pattern</a></p>
</blockquote>
<h5 id="3-Eager-initialization"><a href="#3-Eager-initialization" class="headerlink" title="3. Eager initialization"></a>3. Eager initialization</h5><p>앞의 방식은 <code>getInstance()</code>함수 호출시 객체를 초기화한 것에 반해 이것은 클래스가 로드되는 시점에 객체를 미리 생성하는 방식이다. 이것을 이해하기 위해 클래스의 static 필드가 초기화되는 시점과 객체가 초기화되는 시점을 알아야한다. 클래스의 초기화는 클래스 단위와 객체 단위가 있다. 클래스 단위의 초기화는 클래스를 처음 호출하는 시점에(클래스 초기화 조건에 만족하는 순간) 단 한번 이루어지며 <strong><code>static</code>으로 선언된 멤버변수나 초기화 블럭</strong>이 실행된다. 여기서 실행된 정보는 <em>Runtime Data Area</em> 중 <em>Class(Method) Area</em>에 저장된다. 클래스 단위 초기화(<code>static</code>)가 이루어지는 시점은 로드 타임에 일어난다. 로드 타임은 메모리에 올라오지 않은 클래스를 처음 접근할때 클래스 로더가 해당 클래스 정보를 메모리(<em>Class Area</em>)에 올리는 시점을 말한다. 이 시기는 처음 프로그램이 시작하는 시기일 수도 있고 프로그램이 진행하는 시기일 수도 있다. 클래스 로더가 클래스를 메모리에 올리는 순서는 다음과 같다.</p>
<ol>
<li>어떤 메소드를 호출하는 문장을 만났는데, 그 메소드를 가진 클래스 바이트코드가 아직 로딩된 적이 없다면, 곧바로 JVM은 JRE라이브러리 폴더에서 클래스를 찾는다.</li>
<li>없으면, CLASSPATH 환경변수에 지정된 폴더에서 클래스를 찾는다.</li>
<li>찾았으면 그 클래스 파일이 올바른지 바이트코드를 검증한다.</li>
<li>올바른 바이트코드라면 메소드영역으로 파일을 로딩한다.</li>
<li>클래스 변수를 만들라는 명령어가 있으면 메소드 영역에 그 변수를 준비한다.</li>
<li>클래스 블록이 있으면 순서대로 그 블록을 실행한다.</li>
<li>한번 클래스의 바이트코드가 로드되면 JVM이 종료될때까지 유지된다.</li>
</ol>
<blockquote>
<h5 id="참조-15"><a href="#참조-15" class="headerlink" title="참조"></a>참조</h5><p><a href="http://wanzargen.tistory.com/16" target="_blank" rel="external">자바의 메모리 구조</a></p>
</blockquote>
<p>객체 단위의 초기화는 객체를 생성할때마다 해당 객체별로 초기화가 이루어지며 <strong>멤버 변수와 초기화 블럭</strong>이 실행되고 다음으로 <strong>생성자 내의 코드</strong>가 실행된다. 여기서 발생하는 데이터는 <em>Heap Area</em>에 저장이 된다. 객체 단위 초기화가 이루어지는 시점은 런타임이다. 초기화과정을 알았으면 초기화가 일어나는 조건을 알아야한다. 클래서 초기화가 이루어지기 위해서는 다음의 조건에 만족해야 한다.</p>
<ol>
<li><p>클래스의 인스턴스가 생성될 때(생성자 호출) - 클래스 초기화, 객체 초기화</p>
</li>
<li><p>클래스에서 선언한 정적 필드(<code>static</code>으로 선언된 멤버변수나 멤버함수)가 호출되었을 때 - 클래스 초기화, 멤버 변수가 생성자를 호출할 경우(eager initialization) 객체 초기화도 발생</p>
</li>
<li><p><strong>특히, 클래스에서 호출하는 정적 멤버변수는 <code>fianl</code>이 아니어야 된다.</strong> - <strong>2번</strong>에 대한 예외사항이다. <code>final</code>로 선언된 정적 변수 즉, 상수는 클래스가 로드되는 시점이 아닌 컴파일 시점에 초기화가 일어난다. 외부에서 클래스 내 상수 변수에 접근한다면(ex.<code>Singleton.finalValue</code>) 클래스 초기화가 일어나지 않고 해당 변수값만 가져오게 된다. 따라서 <strong>정적 멤버변수가 <code>final</code>로 선언되었다면 아무런 초기화가 발생하지 않는다.</strong> 컴파일 타임에 초기화되는 상수의 조건은 다음과 같다. </p>
<ol>
<li><code>final</code>로 선언되어 있다.</li>
<li>타입이 기본형이거나 <code>String</code>이어야 한다.</li>
<li>접근자가 <code>public</code>이어야 한다.</li>
<li>선언과 동시에 초기화 된다.</li>
<li><strong>상수로 초기화가 되어야 한다.</strong></li>
</ol>
<p>위의 조건에 만족하는 멤버변수는 컴파일 타임에 초기화가 이루어진다.</p>
<blockquote>
<h5 id="참조-16"><a href="#참조-16" class="headerlink" title="참조"></a>참조</h5><p><a href="https://stackoverflow.com/a/9083023/8453903" target="_blank" rel="external">Compile time constants and variables</a></p>
</blockquote>
</li>
</ol>
<p>이러한 조건에 따라 클래스의 초기화가 일어나며 객체가 생성되었느냐 아니냐에 따라 클래스 단위의 초기화만 일어날지 아니면 객체 단위의 초기화까지 일어날지가 정해진다. 그렇다면 앞전의 <code>Singleton</code>예제 같은 경우 <em>lazy initialization</em>이라고 하였는데 이것은 클래스 초기화가 런타임에 이루어지는 것을 말한다. 자세히 설명하자면 <code>getInstance()</code>를 호출함으로써 함수를 실행하기 전에 클래스 로더가 <code>Singleton</code>클래스를 메모리에 로드시키고 <code>Singleton</code>클래스는 클래스 단위의 초기화를 시작한다. 여기서 <code>static</code>영역은 <code>instance</code> 이기에 이 참조변수를 <em>Class Area</em>에 저장한다. 아직 객체를 할당한 것(<code>new Singleton</code>)은 아니기에 객체단위 초기화는 일어나지 않는다. 이제 클래스 초기화 단계는 끝이 나고 <code>getInstance()</code>함수를 실행한다. 실행 중 객체를 할당하는 <code>new Singleton()</code>명령을 실행하는 순간 객체 단위 초기화가 이루어진다. 여기서 객체 단위 초기화가 이루어지면서 생성자가 실행되고 객체가 할당되기 때문에 <code>lazy initialization</code>이라고 부르며 초기화작업이 완료된다. 반대로 <code>eager initialization</code>은 로더 타임에 <code>instance</code>가 객체 할당까지 되므로 객체 단위 초기화가 일어나면서 생성자도 호출하면서 초기화를 완료하기에 <code>eager</code>라 부르며 이것이 클래스 로드 타임에 이루어진다. <code>eager initialization</code>은 동기화와 성능저하 문제를 해결할 수 있다. 사실상 객체 초기화 시기가 다르다고 말을 하지만 시기상(<code>getInstance()</code>함수를 호출하여 초기화하기까지) 거의 차이가 없다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h5 id="참조-17"><a href="#참조-17" class="headerlink" title="참조"></a>참조</h5><p><a href="http://mdago.tistory.com/1" target="_blank" rel="external">초기화 블럭</a></p>
<p><a href="http://itmore.tistory.com/entry/%EC%9E%90%EB%B0%94-%EB%A1%9C%EB%93%9C%ED%83%80%EC%9E%84-%EB%A1%9C%EB%94%A9-%EB%B0%8F-%EB%9F%B0%ED%83%80%EC%9E%84-%EB%A1%9C%EB%94%A9-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0ClassLoader" target="_blank" rel="external">자바 로드타임 로딩 및 런타임 로딩 이해하기(ClassLoader)</a></p>
<p><a href="http://javacan.tistory.com/entry/1" target="_blank" rel="external">클래스로더1, 동적인 클래스 로딩과 클래스로더</a></p>
<p><a href="https://medium.com/@LIP/singleton%EA%B3%BC-%EC%8A%B5%EA%B4%80%EC%A0%81-%EB%8A%A6%EC%9D%80-%EC%B4%88%EA%B8%B0%ED%99%94-ca94771b398f" target="_blank" rel="external">Medium - Singleton과 습관적 늦은 초기화</a></p>
<p><a href="http://itpangpang.xyz/71" target="_blank" rel="external">static, jvm memory의 기본</a></p>
</blockquote>
<h5 id="4-Using-Enum"><a href="#4-Using-Enum" class="headerlink" title="4. Using Enum"></a>4. Using Enum</h5><p>Java 1.5부터 <code>Enum</code>을 사용하여 <code>Singleton</code>클래스를 간단하게 구현할 수 있다. <code>Enum</code>은 명확하게 <em>thread-safe</em>를 보장할 뿐 아니라 JVM에 의해 <code>Serialization</code>이 보장되며 많은 양의 코드를 줄일 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singlegton &#123;</div><div class="line">    INSTANCE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="5-Initialization-on-demand-holder-idiom-holder에-의한-초기화"><a href="#5-Initialization-on-demand-holder-idiom-holder에-의한-초기화" class="headerlink" title="5. Initialization on demand holder idiom (holder에 의한 초기화)"></a>5. Initialization on demand holder idiom (holder에 의한 초기화)</h5><p>클래스 안에 클래스(Holder)를 두어 JVM의 <em>Class Loader</em> 메커니즘에 의해 <em>Class</em>가 로드되는 시점을 이용한다. <code>Singleton</code>클래스 안에 <code>private static</code>으로 선언된 <code>Holder</code> 클래스를 정의하고 클래스 내부에 <code>public static final</code>로 선언된 <code>Singleton</code> <em>instance</em>를 생성한다. <code>getInstance()</code>함수는 내부에서 <code>Holder</code>클래스의 객체를 반환하는 구조로 설계함으로써 <code>Singleton</code>객체 초기화작업을 <code>Holder</code>클래스가 로드될때 <em>Class Loader</em>에 위임하여 원자성을 보장한다. <code>getInstance()</code>가 호출될때까지 <code>Singleton</code>클래스내 <code>static</code>영역은 초기화가 되지만 객체는 생성되지 않는다. <code>getInstance()</code>함수가 호출되면 객체를 감싸고 있는 <code>LazyHolder</code>클래스가 참조되고 이시점에 <em>Class Loader</em>가 <code>LazyHolder</code>클래스를 메모리에 올리면서 클래스 단위 초기화를 진행한다. <code>static</code>으로 선언된 <code>Singleton</code>객체는 비로서 <em>Class Loader</em>에 의해 생성된다. <em>lazy initialization</em>을 사용하기에 메모리 사용이 효율적이고, <code>synchronized</code>키워드를 사용하지 않기에 성능 저하 문제도 발생하지 않는다. 이것은 <em>Class Loader</em>의 동기화 속성에 의해 가능한 일인데 만약 여러 스레드가 <code>getInstance()</code>에 동시 접근할시 JVM은 클래스를 초기화하기 위해 필드 접근을 동기화하게 되고 이때 <code>Singleton</code>객체가 생성되면 그 다음부터의 접근은 생성된 객체를 참조하게 된다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> LazyHolder.instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Singleton-and-Serialization"><a href="#Singleton-and-Serialization" class="headerlink" title="Singleton and Serialization"></a>Singleton and Serialization</h5><p><code>Serialization</code>은 자바 프로그램 내의 객체 또는 데이터를 외부의 자바 시스템에도 사용할 수 있게 <strong>바이트</strong>형태로 변환하는 기술과 변환된 데이터를 다시 객체로 변환하는 기술을 아울러 말한다. 그러나 직렬화(Serialization)한 객체를 여러번 역직렬화(Deserialization)하면 <code>Singleton</code>객체가 여러개 생산될 수 있는 문제가 발생한다. 이러한 이유때문에 <code>readResolve()</code>라는 함수를 <code>Singleton</code>클래스 안에 구현해야하며, 이 함수를 통해 역직렬화가 완료된 후 생성된 유일한 객체를 반환하도록 보장할 수 있다. 역직렬화시 <code>ObjectInputStream</code> 객체에 <code>readObject()</code>를 호출함으로써 객체를 생성한다. <code>readObject()</code>는 파라미터가 없는 기본생성자를 호출함으로써 객체를 생성하므로 역직렬화를 반복하면 여러개의 <code>Singleton</code>객체가 생성될 수 있다. <code>readResolve()</code>를 구현하면 객체를 생성할때 <code>readObject()</code> 대신 <code>readResolve()</code>함수를 쓰게 되다. 따라서 생성된 정적 객체를 반환하도록 구현하면 역직렬화를 반복하더라도 유일한 객체 생성을 보장할 수 있다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serialization</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// readResolve 함수는 역직렬화가 완료된 후에 즉시 호출된다. </span></div><div class="line">    <span class="comment">// 따라서 역직렬화가 완료된 유일한 객체를 반환하여 중복 생성을 막을 수 있다.</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h5 id="참조-18"><a href="#참조-18" class="headerlink" title="참조"></a>참조</h5><p><a href="https://crackjamx.wordpress.com/2013/02/07/java-synchronized-%EC%A3%BC%EC%9D%98%EC%A0%90/" target="_blank" rel="external">Java-Synchronized 주의점</a></p>
<p><a href="http://jeong-pro.tistory.com/86" target="_blank" rel="external">싱글톤 패턴을 쓰는 이유와 문제점</a></p>
<p><a href="http://asfirstalways.tistory.com/335" target="_blank" rel="external">싱글턴 패턴(Singleton pattern)</a></p>
<p><a href="https://dzone.com/articles/always-start-with-eager-initialisation" target="_blank" rel="external">Always Start With Eager Initialization</a></p>
<p><a href="https://javarevealed.wordpress.com/tag/eager-initialization/" target="_blank" rel="external">Singleton Design Pattern</a></p>
<p><a href="http://woowabros.github.io/experience/2017/10/17/java-serialize.html" target="_blank" rel="external">우아한 형제들 - 자바 직렬화, 그것이 알고싶다. 훑어보기편</a></p>
<p><a href="https://stackoverflow.com/questions/1168348/java-serialization-readobject-vs-readresolve" target="_blank" rel="external">StackOverFlow - Java serialization: readObject() vs readResolve()</a></p>
<p><a href="https://stackoverflow.com/questions/8141440/how-are-constructors-called-during-serialization-and-deserialization" target="_blank" rel="external">How are constructors called during serialization ans deserialization</a></p>
<p><a href="http://kwanseob.blogspot.kr/2012/08/java-volatile.html" target="_blank" rel="external">Java의 volatile 키워드에 대한 이해</a></p>
</blockquote>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#취업준비" >
    <span class="tag-code">취업준비</span>
  </a>

      </div>
    
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2018/03/15/데이터베이스 면접/">
        <span class="nav-arrow">← </span>
        
          데이터베이스 면접
        
      </a>
    
    
  </div>

    
      <div class="money-like">
        <div class="reward-btn">
          후원
        <span class="money-code">
          <span class="kakaopay-code">
            <div class="code-image"></div>
          </span>
        </span>
        </div>
      <p class="notice">이 포스트가 도움이 되었다고 생각하시면, 위의 버튼을 클릭하여 후원해주세요.</p>
      </div>
    
    
      <div class="qrcode">
        <canvas id="share-qrcode"></canvas>
      <p class="notice">이 포스트를 공유하려면 QR 코드를 스캔하세요.</p>
      </div>
    
    
      <div id="comments"></div>
      <!-- Gitment END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#View가-그려지는-과정"><span class="toc-nav-text">View가 그려지는 과정</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#measure-int-widthMeasureSpec-int-heightMeasureSpec"><span class="toc-nav-text">measure(int widthMeasureSpec, int heightMeasureSpec)</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#ViewGroup-LayoutParams"><span class="toc-nav-text">ViewGroup.LayoutParams</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#ViewGroup-MeasureSpec"><span class="toc-nav-text">ViewGroup.MeasureSpec</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#layout-int-l-int-t-int-r-int-b"><span class="toc-nav-text">layout(int l, int t, int r, int b)</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#참조"><span class="toc-nav-text">참조</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#View-Lifecycle"><span class="toc-nav-text">View Lifecycle</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#Constructor"><span class="toc-nav-text">Constructor</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#onAttachedToWindow"><span class="toc-nav-text">onAttachedToWindow</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#onMeasure"><span class="toc-nav-text">onMeasure</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#onLayout"><span class="toc-nav-text">onLayout</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#onDraw"><span class="toc-nav-text">onDraw</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#View-Update"><span class="toc-nav-text">View Update</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#invalidate"><span class="toc-nav-text">invalidate()</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#requestLayout"><span class="toc-nav-text">requestLayout()</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#Animation"><span class="toc-nav-text">Animation</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#참조-1"><span class="toc-nav-text">참조</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Activity-Lifecycle"><span class="toc-nav-text">Activity Lifecycle</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#onCreate"><span class="toc-nav-text">onCreate</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#onRestart"><span class="toc-nav-text">onRestart</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#onStart"><span class="toc-nav-text">onStart</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#onResume"><span class="toc-nav-text">onResume</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#onPause"><span class="toc-nav-text">onPause</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#onStop"><span class="toc-nav-text">onStop</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#onDestroy"><span class="toc-nav-text">onDestroy</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#참조-2"><span class="toc-nav-text">참조</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#안드로이드에서-ENUM-사용을-자제시키는-이유"><span class="toc-nav-text">안드로이드에서 ENUM 사용을 자제시키는 이유</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#참조-3"><span class="toc-nav-text">참조</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#대용량-Bitmap을-불러올-경우-메모리-문제를-해결하는-방법"><span class="toc-nav-text">대용량 Bitmap을 불러올 경우 메모리 문제를 해결하는 방법</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#createScaledBitmap-Bitmap-bitmap-int-width-int-height"><span class="toc-nav-text">createScaledBitmap(Bitmap bitmap, int width, int height)</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#Bitmap-Options-inSampleSize"><span class="toc-nav-text">Bitmap.Options.inSampleSize</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#Bitmap-Options-inScaled-Bitmap-Options-inDensity"><span class="toc-nav-text">Bitmap.Options.inScaled / Bitmap.Options.inDensity</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#Combine-inSampleSize-amp-inScaled-amp-inDensity"><span class="toc-nav-text">Combine inSampleSize & inScaled & inDensity</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#Bitmap-Options-inJustDecodeBounds"><span class="toc-nav-text">Bitmap.Options.inJustDecodeBounds</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#참조-4"><span class="toc-nav-text">참조</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#String-Literal"><span class="toc-nav-text">String Literal</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#참조-5"><span class="toc-nav-text">참조</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Annotation-생성방법-관점프로그래밍"><span class="toc-nav-text">Annotation 생성방법 (관점프로그래밍)</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#Built-in-Annotation"><span class="toc-nav-text">Built-in Annotation</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#Meta-Annotation"><span class="toc-nav-text">Meta-Annotation</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#Custom-Annotation"><span class="toc-nav-text">Custom Annotation</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#참조-6"><span class="toc-nav-text">참조</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#프로세스와-스레드의-차이"><span class="toc-nav-text">프로세스와 스레드의 차이</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#여러-프로세스를-통해-작업을-하지-않고-스레드를-사용하는-이유"><span class="toc-nav-text">여러 프로세스를 통해 작업을 하지 않고 스레드를 사용하는 이유</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#참조-7"><span class="toc-nav-text">참조</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Vector-vs-ArrayList-vs-LinkedList"><span class="toc-nav-text">Vector vs ArrayList vs LinkedList</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#ArrayList"><span class="toc-nav-text">ArrayList</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#LinkedList"><span class="toc-nav-text">LinkedList</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#참조-8"><span class="toc-nav-text">참조</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Quick-Sort"><span class="toc-nav-text">Quick Sort</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#참조-9"><span class="toc-nav-text">참조</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#다형성-Polymorphism-이란"><span class="toc-nav-text">다형성(Polymorphism)이란</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#참조-10"><span class="toc-nav-text">참조</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Iterator를-쓰지-않고-직접-참조-시-문제점"><span class="toc-nav-text">Iterator를 쓰지 않고 직접 참조 시 문제점</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#참조-11"><span class="toc-nav-text">참조</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#제네릭이란"><span class="toc-nav-text">제네릭이란</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#참조-12"><span class="toc-nav-text">참조</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Singleton-동기화"><span class="toc-nav-text">Singleton 동기화</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#문제점"><span class="toc-nav-text">문제점</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#참조-13"><span class="toc-nav-text">참조</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#정적-클래스-메소드-와-Singleton차이"><span class="toc-nav-text">정적 클래스(메소드)와 Singleton차이</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#Singleton-사용시-멀티-스레드-환경에서-동기화-문제-해결하기"><span class="toc-nav-text">Singleton 사용시 멀티 스레드 환경에서 동기화 문제 해결하기</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#1-Lazy-initialization-게으른-초기화"><span class="toc-nav-text">1. Lazy initialization(게으른 초기화)</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#2-Lazy-initialization-Double-checked-locking"><span class="toc-nav-text">2. Lazy initialization + Double-checked locking</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#참조-14"><span class="toc-nav-text">참조</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#3-Eager-initialization"><span class="toc-nav-text">3. Eager initialization</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#참조-15"><span class="toc-nav-text">참조</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#참조-16"><span class="toc-nav-text">참조</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#참조-17"><span class="toc-nav-text">참조</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#4-Using-Enum"><span class="toc-nav-text">4. Using Enum</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#5-Initialization-on-demand-holder-idiom-holder에-의한-초기화"><span class="toc-nav-text">5. Initialization on demand holder idiom (holder에 의한 초기화)</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#Singleton-and-Serialization"><span class="toc-nav-text">Singleton and Serialization</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#참조-18"><span class="toc-nav-text">참조</span></a></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://hyeonu1258.github.io/2018/03/26/안드로이드 면접/';
    var banner = 'undefined'
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "hyeonu1258";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "안드로이드 면접",
        owner: "hyeonu1258",
        repo: "hyeonu1258.github.io",
        oauth: {
          client_id: "058b1d67f791e1b7bb00",
          client_secret: "fbfb73021f7786a1b20ae6d48e54af20534d8c4e"
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2018 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>
  </body>
</html>